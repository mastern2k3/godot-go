package godot

import (
	"github.com/shadowapex/godot-go/gdnative"
)

/*------------------------------------------------------------------------------
//   This code was generated by a tool.
//
//   Changes to this file may cause incorrect behavior and will be lost if
//   the code is regenerated. Any updates should be done in
//   "class.go.tmpl" so they can be included in the generated
//   code.
//----------------------------------------------------------------------------*/

// MeshArrayFormat is an enum for ArrayFormat values.
type MeshArrayFormat int

const (
	MeshArrayCompressBase      MeshArrayFormat = 9
	MeshArrayCompressBones     MeshArrayFormat = 32768
	MeshArrayCompressColor     MeshArrayFormat = 4096
	MeshArrayCompressDefault   MeshArrayFormat = 97280
	MeshArrayCompressIndex     MeshArrayFormat = 131072
	MeshArrayCompressNormal    MeshArrayFormat = 1024
	MeshArrayCompressTangent   MeshArrayFormat = 2048
	MeshArrayCompressTexUv     MeshArrayFormat = 8192
	MeshArrayCompressTexUv2    MeshArrayFormat = 16384
	MeshArrayCompressVertex    MeshArrayFormat = 512
	MeshArrayCompressWeights   MeshArrayFormat = 65536
	MeshArrayFlagUse16BitBones MeshArrayFormat = 524288
	MeshArrayFlagUse2DVertices MeshArrayFormat = 262144
	MeshArrayFormatBones       MeshArrayFormat = 64
	MeshArrayFormatColor       MeshArrayFormat = 8
	MeshArrayFormatIndex       MeshArrayFormat = 256
	MeshArrayFormatNormal      MeshArrayFormat = 2
	MeshArrayFormatTangent     MeshArrayFormat = 4
	MeshArrayFormatTexUv       MeshArrayFormat = 16
	MeshArrayFormatTexUv2      MeshArrayFormat = 32
	MeshArrayFormatVertex      MeshArrayFormat = 1
	MeshArrayFormatWeights     MeshArrayFormat = 128
)

// MeshArrayType is an enum for ArrayType values.
type MeshArrayType int

const (
	MeshArrayBones   MeshArrayType = 6
	MeshArrayColor   MeshArrayType = 3
	MeshArrayIndex   MeshArrayType = 8
	MeshArrayMax     MeshArrayType = 9
	MeshArrayNormal  MeshArrayType = 1
	MeshArrayTangent MeshArrayType = 2
	MeshArrayTexUv   MeshArrayType = 4
	MeshArrayTexUv2  MeshArrayType = 5
	MeshArrayVertex  MeshArrayType = 0
	MeshArrayWeights MeshArrayType = 7
)

// MeshBlendShapeMode is an enum for BlendShapeMode values.
type MeshBlendShapeMode int

const (
	MeshBlendShapeModeNormalized MeshBlendShapeMode = 0
	MeshBlendShapeModeRelative   MeshBlendShapeMode = 1
)

// MeshPrimitiveType is an enum for PrimitiveType values.
type MeshPrimitiveType int

const (
	MeshPrimitiveLines         MeshPrimitiveType = 1
	MeshPrimitiveLineLoop      MeshPrimitiveType = 3
	MeshPrimitiveLineStrip     MeshPrimitiveType = 2
	MeshPrimitivePoints        MeshPrimitiveType = 0
	MeshPrimitiveTriangles     MeshPrimitiveType = 4
	MeshPrimitiveTriangleFan   MeshPrimitiveType = 6
	MeshPrimitiveTriangleStrip MeshPrimitiveType = 5
)

//func NewMeshFromPointer(ptr gdnative.Pointer) Mesh {
func newMeshFromPointer(ptr gdnative.Pointer) Mesh {
	owner := gdnative.NewObjectFromPointer(ptr)
	obj := Mesh{}
	obj.SetBaseObject(owner)

	return obj
}

/*
Mesh is a type of [Resource] that contains vertex-array based geometry, divided in [i]surfaces[/i]. Each surface contains a completely separate array and a material used to draw it. Design wise, a mesh with multiple surfaces is preferred to a single surface, because objects created in 3D editing software commonly contain multiple materials.
*/
type Mesh struct {
	Resource
	owner gdnative.Object
}

func (o *Mesh) BaseClass() string {
	return "Mesh"
}

/*
        Calculate a [ConvexPolygonShape] from the mesh.
	Args: [], Returns: Shape
*/
func (o *Mesh) CreateConvexShape() ShapeImplementer {
	//log.Println("Calling Mesh.CreateConvexShape()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 0, 0)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Mesh", "create_convex_shape")

	// Call the parent method.
	// Shape
	retPtr := gdnative.NewEmptyObject()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := newShapeFromPointer(retPtr)

	// Check to see if we already have an instance of this object in our Go instance registry.
	if instance, ok := InstanceRegistry.Get(ret.GetBaseObject().ID()); ok {
		return instance.(ShapeImplementer)
	}

	// Check to see what kind of class this is and create it. This is generally used with
	// GetNode().
	className := ret.GetClass()
	if className != "Shape" {
		actualRet := getActualClass(className, ret.GetBaseObject())
		return actualRet.(ShapeImplementer)
	}

	return &ret
}

/*
        Calculate an outline mesh at a defined offset (margin) from the original mesh. Note: Typically returns the vertices in reverse order (e.g. clockwise to anti-clockwise).
	Args: [{ false margin float}], Returns: Mesh
*/
func (o *Mesh) CreateOutline(margin gdnative.Real) MeshImplementer {
	//log.Println("Calling Mesh.CreateOutline()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 1, 1)
	ptrArguments[0] = gdnative.NewPointerFromReal(margin)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Mesh", "create_outline")

	// Call the parent method.
	// Mesh
	retPtr := gdnative.NewEmptyObject()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := newMeshFromPointer(retPtr)

	// Check to see if we already have an instance of this object in our Go instance registry.
	if instance, ok := InstanceRegistry.Get(ret.GetBaseObject().ID()); ok {
		return instance.(MeshImplementer)
	}

	// Check to see what kind of class this is and create it. This is generally used with
	// GetNode().
	className := ret.GetClass()
	if className != "Mesh" {
		actualRet := getActualClass(className, ret.GetBaseObject())
		return actualRet.(MeshImplementer)
	}

	return &ret
}

/*
        Calculate a [ConcavePolygonShape] from the mesh.
	Args: [], Returns: Shape
*/
func (o *Mesh) CreateTrimeshShape() ShapeImplementer {
	//log.Println("Calling Mesh.CreateTrimeshShape()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 0, 0)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Mesh", "create_trimesh_shape")

	// Call the parent method.
	// Shape
	retPtr := gdnative.NewEmptyObject()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := newShapeFromPointer(retPtr)

	// Check to see if we already have an instance of this object in our Go instance registry.
	if instance, ok := InstanceRegistry.Get(ret.GetBaseObject().ID()); ok {
		return instance.(ShapeImplementer)
	}

	// Check to see what kind of class this is and create it. This is generally used with
	// GetNode().
	className := ret.GetClass()
	if className != "Shape" {
		actualRet := getActualClass(className, ret.GetBaseObject())
		return actualRet.(ShapeImplementer)
	}

	return &ret
}

/*
        Generate a [TriangleMesh] from the mesh.
	Args: [], Returns: TriangleMesh
*/
func (o *Mesh) GenerateTriangleMesh() TriangleMeshImplementer {
	//log.Println("Calling Mesh.GenerateTriangleMesh()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 0, 0)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Mesh", "generate_triangle_mesh")

	// Call the parent method.
	// TriangleMesh
	retPtr := gdnative.NewEmptyObject()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := newTriangleMeshFromPointer(retPtr)

	// Check to see if we already have an instance of this object in our Go instance registry.
	if instance, ok := InstanceRegistry.Get(ret.GetBaseObject().ID()); ok {
		return instance.(TriangleMeshImplementer)
	}

	// Check to see what kind of class this is and create it. This is generally used with
	// GetNode().
	className := ret.GetClass()
	if className != "TriangleMesh" {
		actualRet := getActualClass(className, ret.GetBaseObject())
		return actualRet.(TriangleMeshImplementer)
	}

	return &ret
}

/*
        Returns all the vertices that make up the faces of the mesh. Each three vertices represent one triangle.
	Args: [], Returns: PoolVector3Array
*/
func (o *Mesh) GetFaces() gdnative.PoolVector3Array {
	//log.Println("Calling Mesh.GetFaces()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 0, 0)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Mesh", "get_faces")

	// Call the parent method.
	// PoolVector3Array
	retPtr := gdnative.NewEmptyPoolVector3Array()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := gdnative.NewPoolVector3ArrayFromPointer(retPtr)
	return ret
}

/*
        Undocumented
	Args: [], Returns: Vector2
*/
func (o *Mesh) GetLightmapSizeHint() gdnative.Vector2 {
	//log.Println("Calling Mesh.GetLightmapSizeHint()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 0, 0)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Mesh", "get_lightmap_size_hint")

	// Call the parent method.
	// Vector2
	retPtr := gdnative.NewEmptyVector2()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := gdnative.NewVector2FromPointer(retPtr)
	return ret
}

/*
        Return the amount of surfaces that the [code]Mesh[/code] holds.
	Args: [], Returns: int
*/
func (o *Mesh) GetSurfaceCount() gdnative.Int {
	//log.Println("Calling Mesh.GetSurfaceCount()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 0, 0)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Mesh", "get_surface_count")

	// Call the parent method.
	// int
	retPtr := gdnative.NewEmptyInt()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := gdnative.NewIntFromPointer(retPtr)
	return ret
}

/*
        Undocumented
	Args: [{ false size Vector2}], Returns: void
*/
func (o *Mesh) SetLightmapSizeHint(size gdnative.Vector2) {
	//log.Println("Calling Mesh.SetLightmapSizeHint()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 1, 1)
	ptrArguments[0] = gdnative.NewPointerFromVector2(size)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Mesh", "set_lightmap_size_hint")

	// Call the parent method.
	// void
	retPtr := gdnative.NewEmptyVoid()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

}

/*
        Returns the arrays for the vertices, normals, uvs, etc. that make up the requested surface (see [method ArrayMesh.add_surface_from_arrays]).
	Args: [{ false surf_idx int}], Returns: Array
*/
func (o *Mesh) SurfaceGetArrays(surfIdx gdnative.Int) gdnative.Array {
	//log.Println("Calling Mesh.SurfaceGetArrays()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 1, 1)
	ptrArguments[0] = gdnative.NewPointerFromInt(surfIdx)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Mesh", "surface_get_arrays")

	// Call the parent method.
	// Array
	retPtr := gdnative.NewEmptyArray()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := gdnative.NewArrayFromPointer(retPtr)
	return ret
}

/*
        Returns the blend shape arrays for the requested surface.
	Args: [{ false surf_idx int}], Returns: Array
*/
func (o *Mesh) SurfaceGetBlendShapeArrays(surfIdx gdnative.Int) gdnative.Array {
	//log.Println("Calling Mesh.SurfaceGetBlendShapeArrays()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 1, 1)
	ptrArguments[0] = gdnative.NewPointerFromInt(surfIdx)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Mesh", "surface_get_blend_shape_arrays")

	// Call the parent method.
	// Array
	retPtr := gdnative.NewEmptyArray()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := gdnative.NewArrayFromPointer(retPtr)
	return ret
}

/*
        Return a [Material] in a given surface. Surface is rendered using this material.
	Args: [{ false surf_idx int}], Returns: Material
*/
func (o *Mesh) SurfaceGetMaterial(surfIdx gdnative.Int) MaterialImplementer {
	//log.Println("Calling Mesh.SurfaceGetMaterial()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 1, 1)
	ptrArguments[0] = gdnative.NewPointerFromInt(surfIdx)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Mesh", "surface_get_material")

	// Call the parent method.
	// Material
	retPtr := gdnative.NewEmptyObject()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := newMaterialFromPointer(retPtr)

	// Check to see if we already have an instance of this object in our Go instance registry.
	if instance, ok := InstanceRegistry.Get(ret.GetBaseObject().ID()); ok {
		return instance.(MaterialImplementer)
	}

	// Check to see what kind of class this is and create it. This is generally used with
	// GetNode().
	className := ret.GetClass()
	if className != "Material" {
		actualRet := getActualClass(className, ret.GetBaseObject())
		return actualRet.(MaterialImplementer)
	}

	return &ret
}

// MeshImplementer is an interface that implements the methods
// of the Mesh class.
type MeshImplementer interface {
	ResourceImplementer
	CreateConvexShape() ShapeImplementer
	CreateOutline(margin gdnative.Real) MeshImplementer
	CreateTrimeshShape() ShapeImplementer
	GenerateTriangleMesh() TriangleMeshImplementer
	GetFaces() gdnative.PoolVector3Array
	GetLightmapSizeHint() gdnative.Vector2
	GetSurfaceCount() gdnative.Int
	SetLightmapSizeHint(size gdnative.Vector2)
	SurfaceGetArrays(surfIdx gdnative.Int) gdnative.Array
	SurfaceGetBlendShapeArrays(surfIdx gdnative.Int) gdnative.Array
	SurfaceGetMaterial(surfIdx gdnative.Int) MaterialImplementer
}
