package godot

import (
	"github.com/shadowapex/godot-go/gdnative"
)

/*------------------------------------------------------------------------------
//   This code was generated by a tool.
//
//   Changes to this file may cause incorrect behavior and will be lost if
//   the code is regenerated. Any updates should be done in
//   "class.go.tmpl" so they can be included in the generated
//   code.
//----------------------------------------------------------------------------*/

// TweenEaseType is an enum for EaseType values.
type TweenEaseType int

const (
	TweenEaseIn    TweenEaseType = 0
	TweenEaseInOut TweenEaseType = 2
	TweenEaseOut   TweenEaseType = 1
	TweenEaseOutIn TweenEaseType = 3
)

// TweenTransitionType is an enum for TransitionType values.
type TweenTransitionType int

const (
	TweenTransBack    TweenTransitionType = 10
	TweenTransBounce  TweenTransitionType = 9
	TweenTransCirc    TweenTransitionType = 8
	TweenTransCubic   TweenTransitionType = 7
	TweenTransElastic TweenTransitionType = 6
	TweenTransExpo    TweenTransitionType = 5
	TweenTransLinear  TweenTransitionType = 0
	TweenTransQuad    TweenTransitionType = 4
	TweenTransQuart   TweenTransitionType = 3
	TweenTransQuint   TweenTransitionType = 2
	TweenTransSine    TweenTransitionType = 1
)

// TweenTweenProcessMode is an enum for TweenProcessMode values.
type TweenTweenProcessMode int

const (
	TweenTweenProcessIdle    TweenTweenProcessMode = 1
	TweenTweenProcessPhysics TweenTweenProcessMode = 0
)

//func NewTweenFromPointer(ptr gdnative.Pointer) Tween {
func newTweenFromPointer(ptr gdnative.Pointer) Tween {
	owner := gdnative.NewObjectFromPointer(ptr)
	obj := Tween{}
	obj.SetBaseObject(owner)

	return obj
}

/*
Tweens are useful for animations requiring a numerical property to be interpolated over a range of values. The name *tween* comes from *in-betweening*, an animation technique where you specify *keyframes* and the computer interpolates the frames that appear between them. Here is a brief usage example that causes a 2D node to move smoothly between two positions: [codeblock] var tween = get_node("Tween") tween.interpolate_property($Node2D, "position", Vector2(0, 0), Vector2(100, 100), 1, Tween.TRANS_LINEAR, Tween.EASE_IN_OUT) tween.start() [/codeblock] Many methods require a property name, such as "position" above. You can find the correct property name by hovering over the property in the Inspector. You can also provide the components of a property directly by using "property:component" (eg. [code]position:x[/code]), where it would only apply to that particular component. Many of the methods accept [code]trans_type[/code] and [code]ease_type[/code]. The first accepts an [enum TransitionType] constant, and refers to the way the timing of the animation is handled (see [code]http://easings.net/[/code] for some examples). The second accepts an [enum EaseType] constant, and controls the where [code]trans_type[/code] is applied to the interpolation (in the beginning, the end, or both). If you don't know which transition and easing to pick, you can try different [enum TransitionType] constants with [code]EASE_IN_OUT[/code], and use the one that looks best.
*/
type Tween struct {
	Node
	owner gdnative.Object
}

func (o *Tween) BaseClass() string {
	return "Tween"
}

/*
        Undocumented
	Args: [{ false uid int}], Returns: void
*/
func (o *Tween) X_RemoveByUid(uid gdnative.Int) {
	//log.Println("Calling Tween.X_RemoveByUid()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 1, 1)
	ptrArguments[0] = gdnative.NewPointerFromInt(uid)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Tween", "_remove_by_uid")

	// Call the parent method.
	// void
	retPtr := gdnative.NewEmptyVoid()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

}

/*
        Follows [code]method[/code] of [code]object[/code] and applies the returned value on [code]target_method[/code] of [code]target[/code], beginning from [code]initial_val[/code] for [code]duration[/code] seconds, [code]delay[/code] later. Methods are called with consecutive values. Use [enum TransitionType] for [code]trans_type[/code] and [enum EaseType] for [code]ease_type[/code] parameters. These values control the timing and direction of the interpolation. See the class description for more information
	Args: [{ false object Object} { false method String} { false initial_val Variant} { false target Object} { false target_method String} { false duration float} { false trans_type int} { false ease_type int} {0 true delay float}], Returns: bool
*/
func (o *Tween) FollowMethod(object ObjectImplementer, method gdnative.String, initialVal gdnative.Variant, target ObjectImplementer, targetMethod gdnative.String, duration gdnative.Real, transType gdnative.Int, easeType gdnative.Int, delay gdnative.Real) gdnative.Bool {
	//log.Println("Calling Tween.FollowMethod()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 9, 9)
	ptrArguments[0] = gdnative.NewPointerFromObject(object.GetBaseObject())
	ptrArguments[1] = gdnative.NewPointerFromString(method)
	ptrArguments[2] = gdnative.NewPointerFromVariant(initialVal)
	ptrArguments[3] = gdnative.NewPointerFromObject(target.GetBaseObject())
	ptrArguments[4] = gdnative.NewPointerFromString(targetMethod)
	ptrArguments[5] = gdnative.NewPointerFromReal(duration)
	ptrArguments[6] = gdnative.NewPointerFromInt(transType)
	ptrArguments[7] = gdnative.NewPointerFromInt(easeType)
	ptrArguments[8] = gdnative.NewPointerFromReal(delay)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Tween", "follow_method")

	// Call the parent method.
	// bool
	retPtr := gdnative.NewEmptyBool()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := gdnative.NewBoolFromPointer(retPtr)
	return ret
}

/*
        Follows [code]property[/code] of [code]object[/code] and applies it on [code]target_property[/code] of [code]target[/code], beginning from [code]initial_val[/code] for [code]duration[/code] seconds, [code]delay[/code] seconds later. Use [enum TransitionType] for [code]trans_type[/code] and [enum EaseType] for [code]ease_type[/code] parameters. These values control the timing and direction of the interpolation. See the class description for more information
	Args: [{ false object Object} { false property NodePath} { false initial_val Variant} { false target Object} { false target_property NodePath} { false duration float} { false trans_type int} { false ease_type int} {0 true delay float}], Returns: bool
*/
func (o *Tween) FollowProperty(object ObjectImplementer, property gdnative.NodePath, initialVal gdnative.Variant, target ObjectImplementer, targetProperty gdnative.NodePath, duration gdnative.Real, transType gdnative.Int, easeType gdnative.Int, delay gdnative.Real) gdnative.Bool {
	//log.Println("Calling Tween.FollowProperty()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 9, 9)
	ptrArguments[0] = gdnative.NewPointerFromObject(object.GetBaseObject())
	ptrArguments[1] = gdnative.NewPointerFromNodePath(property)
	ptrArguments[2] = gdnative.NewPointerFromVariant(initialVal)
	ptrArguments[3] = gdnative.NewPointerFromObject(target.GetBaseObject())
	ptrArguments[4] = gdnative.NewPointerFromNodePath(targetProperty)
	ptrArguments[5] = gdnative.NewPointerFromReal(duration)
	ptrArguments[6] = gdnative.NewPointerFromInt(transType)
	ptrArguments[7] = gdnative.NewPointerFromInt(easeType)
	ptrArguments[8] = gdnative.NewPointerFromReal(delay)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Tween", "follow_property")

	// Call the parent method.
	// bool
	retPtr := gdnative.NewEmptyBool()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := gdnative.NewBoolFromPointer(retPtr)
	return ret
}

/*
        Returns the total time needed for all tweens to end. If you have two tweens, one lasting 10 seconds and the other 20 seconds, it would return 20 seconds, as by that time all tweens would have finished.
	Args: [], Returns: float
*/
func (o *Tween) GetRuntime() gdnative.Real {
	//log.Println("Calling Tween.GetRuntime()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 0, 0)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Tween", "get_runtime")

	// Call the parent method.
	// float
	retPtr := gdnative.NewEmptyReal()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := gdnative.NewRealFromPointer(retPtr)
	return ret
}

/*
        Undocumented
	Args: [], Returns: float
*/
func (o *Tween) GetSpeedScale() gdnative.Real {
	//log.Println("Calling Tween.GetSpeedScale()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 0, 0)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Tween", "get_speed_scale")

	// Call the parent method.
	// float
	retPtr := gdnative.NewEmptyReal()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := gdnative.NewRealFromPointer(retPtr)
	return ret
}

/*
        Undocumented
	Args: [], Returns: enum.Tween::TweenProcessMode
*/
func (o *Tween) GetTweenProcessMode() TweenTweenProcessMode {
	//log.Println("Calling Tween.GetTweenProcessMode()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 0, 0)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Tween", "get_tween_process_mode")

	// Call the parent method.
	// enum.Tween::TweenProcessMode
	retPtr := gdnative.NewEmptyInt()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := gdnative.NewIntFromPointer(retPtr)
	return TweenTweenProcessMode(ret)
}

/*
        Calls [code]callback[/code] of [code]object[/code] after [code]duration[/code]. [code]arg1[/code]-[code]arg5[/code] are arguments to be passed to the callback.
	Args: [{ false object Object} { false duration float} { false callback String} {Null true arg1 Variant} {Null true arg2 Variant} {Null true arg3 Variant} {Null true arg4 Variant} {Null true arg5 Variant}], Returns: bool
*/
func (o *Tween) InterpolateCallback(object ObjectImplementer, duration gdnative.Real, callback gdnative.String, arg1 gdnative.Variant, arg2 gdnative.Variant, arg3 gdnative.Variant, arg4 gdnative.Variant, arg5 gdnative.Variant) gdnative.Bool {
	//log.Println("Calling Tween.InterpolateCallback()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 8, 8)
	ptrArguments[0] = gdnative.NewPointerFromObject(object.GetBaseObject())
	ptrArguments[1] = gdnative.NewPointerFromReal(duration)
	ptrArguments[2] = gdnative.NewPointerFromString(callback)
	ptrArguments[3] = gdnative.NewPointerFromVariant(arg1)
	ptrArguments[4] = gdnative.NewPointerFromVariant(arg2)
	ptrArguments[5] = gdnative.NewPointerFromVariant(arg3)
	ptrArguments[6] = gdnative.NewPointerFromVariant(arg4)
	ptrArguments[7] = gdnative.NewPointerFromVariant(arg5)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Tween", "interpolate_callback")

	// Call the parent method.
	// bool
	retPtr := gdnative.NewEmptyBool()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := gdnative.NewBoolFromPointer(retPtr)
	return ret
}

/*
        Calls [code]callback[/code] of [code]object[/code] after [code]duration[/code] on the main thread (similar to [method Object.call_deferred]). [code]arg1[/code]-[code]arg5[/code] are arguments to be passed to the callback.
	Args: [{ false object Object} { false duration float} { false callback String} {Null true arg1 Variant} {Null true arg2 Variant} {Null true arg3 Variant} {Null true arg4 Variant} {Null true arg5 Variant}], Returns: bool
*/
func (o *Tween) InterpolateDeferredCallback(object ObjectImplementer, duration gdnative.Real, callback gdnative.String, arg1 gdnative.Variant, arg2 gdnative.Variant, arg3 gdnative.Variant, arg4 gdnative.Variant, arg5 gdnative.Variant) gdnative.Bool {
	//log.Println("Calling Tween.InterpolateDeferredCallback()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 8, 8)
	ptrArguments[0] = gdnative.NewPointerFromObject(object.GetBaseObject())
	ptrArguments[1] = gdnative.NewPointerFromReal(duration)
	ptrArguments[2] = gdnative.NewPointerFromString(callback)
	ptrArguments[3] = gdnative.NewPointerFromVariant(arg1)
	ptrArguments[4] = gdnative.NewPointerFromVariant(arg2)
	ptrArguments[5] = gdnative.NewPointerFromVariant(arg3)
	ptrArguments[6] = gdnative.NewPointerFromVariant(arg4)
	ptrArguments[7] = gdnative.NewPointerFromVariant(arg5)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Tween", "interpolate_deferred_callback")

	// Call the parent method.
	// bool
	retPtr := gdnative.NewEmptyBool()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := gdnative.NewBoolFromPointer(retPtr)
	return ret
}

/*
        Animates [code]method[/code] of [code]object[/code] from [code]initial_val[/code] to [code]final_val[/code] for [code]duration[/code] seconds, [code]delay[/code] seconds later. Methods are called with consecutive values. Use [enum TransitionType] for [code]trans_type[/code] and [enum EaseType] for [code]ease_type[/code] parameters. These values control the timing and direction of the interpolation. See the class description for more information
	Args: [{ false object Object} { false method String} { false initial_val Variant} { false final_val Variant} { false duration float} { false trans_type int} { false ease_type int} {0 true delay float}], Returns: bool
*/
func (o *Tween) InterpolateMethod(object ObjectImplementer, method gdnative.String, initialVal gdnative.Variant, finalVal gdnative.Variant, duration gdnative.Real, transType gdnative.Int, easeType gdnative.Int, delay gdnative.Real) gdnative.Bool {
	//log.Println("Calling Tween.InterpolateMethod()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 8, 8)
	ptrArguments[0] = gdnative.NewPointerFromObject(object.GetBaseObject())
	ptrArguments[1] = gdnative.NewPointerFromString(method)
	ptrArguments[2] = gdnative.NewPointerFromVariant(initialVal)
	ptrArguments[3] = gdnative.NewPointerFromVariant(finalVal)
	ptrArguments[4] = gdnative.NewPointerFromReal(duration)
	ptrArguments[5] = gdnative.NewPointerFromInt(transType)
	ptrArguments[6] = gdnative.NewPointerFromInt(easeType)
	ptrArguments[7] = gdnative.NewPointerFromReal(delay)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Tween", "interpolate_method")

	// Call the parent method.
	// bool
	retPtr := gdnative.NewEmptyBool()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := gdnative.NewBoolFromPointer(retPtr)
	return ret
}

/*
        Animates [code]property[/code] of [code]object[/code] from [code]initial_val[/code] to [code]final_val[/code] for [code]duration[/code] seconds, [code]delay[/code] seconds later. Setting the initial value to [code]null[/code] uses the current value of the property. Use [enum TransitionType] for [code]trans_type[/code] and [enum EaseType] for [code]ease_type[/code] parameters. These values control the timing and direction of the interpolation. See the class description for more information
	Args: [{ false object Object} { false property NodePath} { false initial_val Variant} { false final_val Variant} { false duration float} { false trans_type int} { false ease_type int} {0 true delay float}], Returns: bool
*/
func (o *Tween) InterpolateProperty(object ObjectImplementer, property gdnative.NodePath, initialVal gdnative.Variant, finalVal gdnative.Variant, duration gdnative.Real, transType gdnative.Int, easeType gdnative.Int, delay gdnative.Real) gdnative.Bool {
	//log.Println("Calling Tween.InterpolateProperty()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 8, 8)
	ptrArguments[0] = gdnative.NewPointerFromObject(object.GetBaseObject())
	ptrArguments[1] = gdnative.NewPointerFromNodePath(property)
	ptrArguments[2] = gdnative.NewPointerFromVariant(initialVal)
	ptrArguments[3] = gdnative.NewPointerFromVariant(finalVal)
	ptrArguments[4] = gdnative.NewPointerFromReal(duration)
	ptrArguments[5] = gdnative.NewPointerFromInt(transType)
	ptrArguments[6] = gdnative.NewPointerFromInt(easeType)
	ptrArguments[7] = gdnative.NewPointerFromReal(delay)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Tween", "interpolate_property")

	// Call the parent method.
	// bool
	retPtr := gdnative.NewEmptyBool()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := gdnative.NewBoolFromPointer(retPtr)
	return ret
}

/*
        Returns [code]true[/code] if any tweens are currently running. Note that this method doesn't consider tweens that have ended.
	Args: [], Returns: bool
*/
func (o *Tween) IsActive() gdnative.Bool {
	//log.Println("Calling Tween.IsActive()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 0, 0)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Tween", "is_active")

	// Call the parent method.
	// bool
	retPtr := gdnative.NewEmptyBool()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := gdnative.NewBoolFromPointer(retPtr)
	return ret
}

/*
        Undocumented
	Args: [], Returns: bool
*/
func (o *Tween) IsRepeat() gdnative.Bool {
	//log.Println("Calling Tween.IsRepeat()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 0, 0)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Tween", "is_repeat")

	// Call the parent method.
	// bool
	retPtr := gdnative.NewEmptyBool()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := gdnative.NewBoolFromPointer(retPtr)
	return ret
}

/*
        Stops animation and removes a tween, given its object and property/method pair. By default, all tweens are removed, unless [code]key[/code] is specified.
	Args: [{ false object Object} { true key String}], Returns: bool
*/
func (o *Tween) Remove(object ObjectImplementer, key gdnative.String) gdnative.Bool {
	//log.Println("Calling Tween.Remove()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 2, 2)
	ptrArguments[0] = gdnative.NewPointerFromObject(object.GetBaseObject())
	ptrArguments[1] = gdnative.NewPointerFromString(key)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Tween", "remove")

	// Call the parent method.
	// bool
	retPtr := gdnative.NewEmptyBool()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := gdnative.NewBoolFromPointer(retPtr)
	return ret
}

/*
        Stops animation and removes all tweens.
	Args: [], Returns: bool
*/
func (o *Tween) RemoveAll() gdnative.Bool {
	//log.Println("Calling Tween.RemoveAll()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 0, 0)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Tween", "remove_all")

	// Call the parent method.
	// bool
	retPtr := gdnative.NewEmptyBool()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := gdnative.NewBoolFromPointer(retPtr)
	return ret
}

/*
        Resets a tween to its initial value (the one given, not the one before the tween), given its object and property/method pair. By default, all tweens are removed, unless [code]key[/code] is specified.
	Args: [{ false object Object} { true key String}], Returns: bool
*/
func (o *Tween) Reset(object ObjectImplementer, key gdnative.String) gdnative.Bool {
	//log.Println("Calling Tween.Reset()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 2, 2)
	ptrArguments[0] = gdnative.NewPointerFromObject(object.GetBaseObject())
	ptrArguments[1] = gdnative.NewPointerFromString(key)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Tween", "reset")

	// Call the parent method.
	// bool
	retPtr := gdnative.NewEmptyBool()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := gdnative.NewBoolFromPointer(retPtr)
	return ret
}

/*
        Resets all tweens to their initial values (the ones given, not those before the tween).
	Args: [], Returns: bool
*/
func (o *Tween) ResetAll() gdnative.Bool {
	//log.Println("Calling Tween.ResetAll()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 0, 0)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Tween", "reset_all")

	// Call the parent method.
	// bool
	retPtr := gdnative.NewEmptyBool()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := gdnative.NewBoolFromPointer(retPtr)
	return ret
}

/*
        Continues animating a stopped tween, given its object and property/method pair. By default, all tweens are resumed, unless [code]key[/code] is specified.
	Args: [{ false object Object} { true key String}], Returns: bool
*/
func (o *Tween) Resume(object ObjectImplementer, key gdnative.String) gdnative.Bool {
	//log.Println("Calling Tween.Resume()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 2, 2)
	ptrArguments[0] = gdnative.NewPointerFromObject(object.GetBaseObject())
	ptrArguments[1] = gdnative.NewPointerFromString(key)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Tween", "resume")

	// Call the parent method.
	// bool
	retPtr := gdnative.NewEmptyBool()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := gdnative.NewBoolFromPointer(retPtr)
	return ret
}

/*
        Continues animating all stopped tweens.
	Args: [], Returns: bool
*/
func (o *Tween) ResumeAll() gdnative.Bool {
	//log.Println("Calling Tween.ResumeAll()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 0, 0)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Tween", "resume_all")

	// Call the parent method.
	// bool
	retPtr := gdnative.NewEmptyBool()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := gdnative.NewBoolFromPointer(retPtr)
	return ret
}

/*
        Sets the interpolation to the given [code]time[/code] in seconds.
	Args: [{ false time float}], Returns: bool
*/
func (o *Tween) Seek(time gdnative.Real) gdnative.Bool {
	//log.Println("Calling Tween.Seek()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 1, 1)
	ptrArguments[0] = gdnative.NewPointerFromReal(time)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Tween", "seek")

	// Call the parent method.
	// bool
	retPtr := gdnative.NewEmptyBool()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := gdnative.NewBoolFromPointer(retPtr)
	return ret
}

/*
        Activates/deactivates the tween. See also [method stop_all] and [method resume_all].
	Args: [{ false active bool}], Returns: void
*/
func (o *Tween) SetActive(active gdnative.Bool) {
	//log.Println("Calling Tween.SetActive()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 1, 1)
	ptrArguments[0] = gdnative.NewPointerFromBool(active)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Tween", "set_active")

	// Call the parent method.
	// void
	retPtr := gdnative.NewEmptyVoid()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

}

/*
        Undocumented
	Args: [{ false repeat bool}], Returns: void
*/
func (o *Tween) SetRepeat(repeat gdnative.Bool) {
	//log.Println("Calling Tween.SetRepeat()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 1, 1)
	ptrArguments[0] = gdnative.NewPointerFromBool(repeat)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Tween", "set_repeat")

	// Call the parent method.
	// void
	retPtr := gdnative.NewEmptyVoid()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

}

/*
        Undocumented
	Args: [{ false speed float}], Returns: void
*/
func (o *Tween) SetSpeedScale(speed gdnative.Real) {
	//log.Println("Calling Tween.SetSpeedScale()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 1, 1)
	ptrArguments[0] = gdnative.NewPointerFromReal(speed)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Tween", "set_speed_scale")

	// Call the parent method.
	// void
	retPtr := gdnative.NewEmptyVoid()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

}

/*
        Undocumented
	Args: [{ false mode int}], Returns: void
*/
func (o *Tween) SetTweenProcessMode(mode gdnative.Int) {
	//log.Println("Calling Tween.SetTweenProcessMode()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 1, 1)
	ptrArguments[0] = gdnative.NewPointerFromInt(mode)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Tween", "set_tween_process_mode")

	// Call the parent method.
	// void
	retPtr := gdnative.NewEmptyVoid()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

}

/*
        Starts the tween. You can define animations both before and after this.
	Args: [], Returns: bool
*/
func (o *Tween) Start() gdnative.Bool {
	//log.Println("Calling Tween.Start()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 0, 0)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Tween", "start")

	// Call the parent method.
	// bool
	retPtr := gdnative.NewEmptyBool()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := gdnative.NewBoolFromPointer(retPtr)
	return ret
}

/*
        Stops a tween, given its object and property/method pair. By default, all tweens are stopped, unless [code]key[/code] is specified.
	Args: [{ false object Object} { true key String}], Returns: bool
*/
func (o *Tween) Stop(object ObjectImplementer, key gdnative.String) gdnative.Bool {
	//log.Println("Calling Tween.Stop()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 2, 2)
	ptrArguments[0] = gdnative.NewPointerFromObject(object.GetBaseObject())
	ptrArguments[1] = gdnative.NewPointerFromString(key)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Tween", "stop")

	// Call the parent method.
	// bool
	retPtr := gdnative.NewEmptyBool()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := gdnative.NewBoolFromPointer(retPtr)
	return ret
}

/*
        Stops animating all tweens.
	Args: [], Returns: bool
*/
func (o *Tween) StopAll() gdnative.Bool {
	//log.Println("Calling Tween.StopAll()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 0, 0)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Tween", "stop_all")

	// Call the parent method.
	// bool
	retPtr := gdnative.NewEmptyBool()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := gdnative.NewBoolFromPointer(retPtr)
	return ret
}

/*
        Animates [code]method[/code] of [code]object[/code] from the value returned by [code]initial_method[/code] to [code]final_val[/code] for [code]duration[/code] seconds, [code]delay[/code] seconds later. Methods are animated by calling them with consecutive values. Use [enum TransitionType] for [code]trans_type[/code] and [enum EaseType] for [code]ease_type[/code] parameters. These values control the timing and direction of the interpolation. See the class description for more information
	Args: [{ false object Object} { false method String} { false initial Object} { false initial_method String} { false final_val Variant} { false duration float} { false trans_type int} { false ease_type int} {0 true delay float}], Returns: bool
*/
func (o *Tween) TargetingMethod(object ObjectImplementer, method gdnative.String, initial ObjectImplementer, initialMethod gdnative.String, finalVal gdnative.Variant, duration gdnative.Real, transType gdnative.Int, easeType gdnative.Int, delay gdnative.Real) gdnative.Bool {
	//log.Println("Calling Tween.TargetingMethod()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 9, 9)
	ptrArguments[0] = gdnative.NewPointerFromObject(object.GetBaseObject())
	ptrArguments[1] = gdnative.NewPointerFromString(method)
	ptrArguments[2] = gdnative.NewPointerFromObject(initial.GetBaseObject())
	ptrArguments[3] = gdnative.NewPointerFromString(initialMethod)
	ptrArguments[4] = gdnative.NewPointerFromVariant(finalVal)
	ptrArguments[5] = gdnative.NewPointerFromReal(duration)
	ptrArguments[6] = gdnative.NewPointerFromInt(transType)
	ptrArguments[7] = gdnative.NewPointerFromInt(easeType)
	ptrArguments[8] = gdnative.NewPointerFromReal(delay)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Tween", "targeting_method")

	// Call the parent method.
	// bool
	retPtr := gdnative.NewEmptyBool()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := gdnative.NewBoolFromPointer(retPtr)
	return ret
}

/*
        Animates [code]property[/code] of [code]object[/code] from the current value of the [code]initial_val[/code] property of [code]initial[/code] to [code]final_val[/code] for [code]duration[/code] seconds, [code]delay[/code] seconds later. Use [enum TransitionType] for [code]trans_type[/code] and [enum EaseType] for [code]ease_type[/code] parameters. These values control the timing and direction of the interpolation. See the class description for more information
	Args: [{ false object Object} { false property NodePath} { false initial Object} { false initial_val NodePath} { false final_val Variant} { false duration float} { false trans_type int} { false ease_type int} {0 true delay float}], Returns: bool
*/
func (o *Tween) TargetingProperty(object ObjectImplementer, property gdnative.NodePath, initial ObjectImplementer, initialVal gdnative.NodePath, finalVal gdnative.Variant, duration gdnative.Real, transType gdnative.Int, easeType gdnative.Int, delay gdnative.Real) gdnative.Bool {
	//log.Println("Calling Tween.TargetingProperty()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 9, 9)
	ptrArguments[0] = gdnative.NewPointerFromObject(object.GetBaseObject())
	ptrArguments[1] = gdnative.NewPointerFromNodePath(property)
	ptrArguments[2] = gdnative.NewPointerFromObject(initial.GetBaseObject())
	ptrArguments[3] = gdnative.NewPointerFromNodePath(initialVal)
	ptrArguments[4] = gdnative.NewPointerFromVariant(finalVal)
	ptrArguments[5] = gdnative.NewPointerFromReal(duration)
	ptrArguments[6] = gdnative.NewPointerFromInt(transType)
	ptrArguments[7] = gdnative.NewPointerFromInt(easeType)
	ptrArguments[8] = gdnative.NewPointerFromReal(delay)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Tween", "targeting_property")

	// Call the parent method.
	// bool
	retPtr := gdnative.NewEmptyBool()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := gdnative.NewBoolFromPointer(retPtr)
	return ret
}

/*
        Returns the current time of the tween.
	Args: [], Returns: float
*/
func (o *Tween) Tell() gdnative.Real {
	//log.Println("Calling Tween.Tell()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 0, 0)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Tween", "tell")

	// Call the parent method.
	// float
	retPtr := gdnative.NewEmptyReal()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := gdnative.NewRealFromPointer(retPtr)
	return ret
}

// TweenImplementer is an interface that implements the methods
// of the Tween class.
type TweenImplementer interface {
	NodeImplementer
	X_RemoveByUid(uid gdnative.Int)
	FollowMethod(object ObjectImplementer, method gdnative.String, initialVal gdnative.Variant, target ObjectImplementer, targetMethod gdnative.String, duration gdnative.Real, transType gdnative.Int, easeType gdnative.Int, delay gdnative.Real) gdnative.Bool
	FollowProperty(object ObjectImplementer, property gdnative.NodePath, initialVal gdnative.Variant, target ObjectImplementer, targetProperty gdnative.NodePath, duration gdnative.Real, transType gdnative.Int, easeType gdnative.Int, delay gdnative.Real) gdnative.Bool
	GetRuntime() gdnative.Real
	GetSpeedScale() gdnative.Real
	InterpolateCallback(object ObjectImplementer, duration gdnative.Real, callback gdnative.String, arg1 gdnative.Variant, arg2 gdnative.Variant, arg3 gdnative.Variant, arg4 gdnative.Variant, arg5 gdnative.Variant) gdnative.Bool
	InterpolateDeferredCallback(object ObjectImplementer, duration gdnative.Real, callback gdnative.String, arg1 gdnative.Variant, arg2 gdnative.Variant, arg3 gdnative.Variant, arg4 gdnative.Variant, arg5 gdnative.Variant) gdnative.Bool
	InterpolateMethod(object ObjectImplementer, method gdnative.String, initialVal gdnative.Variant, finalVal gdnative.Variant, duration gdnative.Real, transType gdnative.Int, easeType gdnative.Int, delay gdnative.Real) gdnative.Bool
	InterpolateProperty(object ObjectImplementer, property gdnative.NodePath, initialVal gdnative.Variant, finalVal gdnative.Variant, duration gdnative.Real, transType gdnative.Int, easeType gdnative.Int, delay gdnative.Real) gdnative.Bool
	IsActive() gdnative.Bool
	IsRepeat() gdnative.Bool
	Remove(object ObjectImplementer, key gdnative.String) gdnative.Bool
	RemoveAll() gdnative.Bool
	Reset(object ObjectImplementer, key gdnative.String) gdnative.Bool
	ResetAll() gdnative.Bool
	Resume(object ObjectImplementer, key gdnative.String) gdnative.Bool
	ResumeAll() gdnative.Bool
	Seek(time gdnative.Real) gdnative.Bool
	SetActive(active gdnative.Bool)
	SetRepeat(repeat gdnative.Bool)
	SetSpeedScale(speed gdnative.Real)
	SetTweenProcessMode(mode gdnative.Int)
	Start() gdnative.Bool
	Stop(object ObjectImplementer, key gdnative.String) gdnative.Bool
	StopAll() gdnative.Bool
	TargetingMethod(object ObjectImplementer, method gdnative.String, initial ObjectImplementer, initialMethod gdnative.String, finalVal gdnative.Variant, duration gdnative.Real, transType gdnative.Int, easeType gdnative.Int, delay gdnative.Real) gdnative.Bool
	TargetingProperty(object ObjectImplementer, property gdnative.NodePath, initial ObjectImplementer, initialVal gdnative.NodePath, finalVal gdnative.Variant, duration gdnative.Real, transType gdnative.Int, easeType gdnative.Int, delay gdnative.Real) gdnative.Bool
	Tell() gdnative.Real
}
