package godot

import (
	"github.com/shadowapex/godot-go/gdnative"
)

/*------------------------------------------------------------------------------
//   This code was generated by a tool.
//
//   Changes to this file may cause incorrect behavior and will be lost if
//   the code is regenerated. Any updates should be done in
//   "class.go.tmpl" so they can be included in the generated
//   code.
//----------------------------------------------------------------------------*/

// ControlAnchor is an enum for Anchor values.
type ControlAnchor int

const (
	ControlAnchorBegin ControlAnchor = 0
	ControlAnchorEnd   ControlAnchor = 1
)

// ControlCursorShape is an enum for CursorShape values.
type ControlCursorShape int

const (
	ControlCursorArrow        ControlCursorShape = 0
	ControlCursorBdiagsize    ControlCursorShape = 11
	ControlCursorBusy         ControlCursorShape = 5
	ControlCursorCanDrop      ControlCursorShape = 7
	ControlCursorCross        ControlCursorShape = 3
	ControlCursorDrag         ControlCursorShape = 6
	ControlCursorFdiagsize    ControlCursorShape = 12
	ControlCursorForbidden    ControlCursorShape = 8
	ControlCursorHelp         ControlCursorShape = 16
	ControlCursorHsize        ControlCursorShape = 10
	ControlCursorHsplit       ControlCursorShape = 15
	ControlCursorIbeam        ControlCursorShape = 1
	ControlCursorMove         ControlCursorShape = 13
	ControlCursorPointingHand ControlCursorShape = 2
	ControlCursorVsize        ControlCursorShape = 9
	ControlCursorVsplit       ControlCursorShape = 14
	ControlCursorWait         ControlCursorShape = 4
)

// ControlFocusMode is an enum for FocusMode values.
type ControlFocusMode int

const (
	ControlFocusAll   ControlFocusMode = 2
	ControlFocusClick ControlFocusMode = 1
	ControlFocusNone  ControlFocusMode = 0
)

// ControlGrowDirection is an enum for GrowDirection values.
type ControlGrowDirection int

const (
	ControlGrowDirectionBegin ControlGrowDirection = 0
	ControlGrowDirectionBoth  ControlGrowDirection = 2
	ControlGrowDirectionEnd   ControlGrowDirection = 1
)

// ControlLayoutPreset is an enum for LayoutPreset values.
type ControlLayoutPreset int

const (
	ControlPresetBottomLeft   ControlLayoutPreset = 2
	ControlPresetBottomRight  ControlLayoutPreset = 3
	ControlPresetBottomWide   ControlLayoutPreset = 12
	ControlPresetCenter       ControlLayoutPreset = 8
	ControlPresetCenterBottom ControlLayoutPreset = 7
	ControlPresetCenterLeft   ControlLayoutPreset = 4
	ControlPresetCenterRight  ControlLayoutPreset = 6
	ControlPresetCenterTop    ControlLayoutPreset = 5
	ControlPresetHcenterWide  ControlLayoutPreset = 14
	ControlPresetLeftWide     ControlLayoutPreset = 9
	ControlPresetRightWide    ControlLayoutPreset = 11
	ControlPresetTopLeft      ControlLayoutPreset = 0
	ControlPresetTopRight     ControlLayoutPreset = 1
	ControlPresetTopWide      ControlLayoutPreset = 10
	ControlPresetVcenterWide  ControlLayoutPreset = 13
	ControlPresetWide         ControlLayoutPreset = 15
)

// ControlLayoutPresetMode is an enum for LayoutPresetMode values.
type ControlLayoutPresetMode int

const (
	ControlPresetModeKeepHeight ControlLayoutPresetMode = 2
	ControlPresetModeKeepSize   ControlLayoutPresetMode = 3
	ControlPresetModeKeepWidth  ControlLayoutPresetMode = 1
	ControlPresetModeMinsize    ControlLayoutPresetMode = 0
)

// ControlMouseFilter is an enum for MouseFilter values.
type ControlMouseFilter int

const (
	ControlMouseFilterIgnore ControlMouseFilter = 2
	ControlMouseFilterPass   ControlMouseFilter = 1
	ControlMouseFilterStop   ControlMouseFilter = 0
)

// ControlSizeFlags is an enum for SizeFlags values.
type ControlSizeFlags int

const (
	ControlSizeExpand       ControlSizeFlags = 2
	ControlSizeExpandFill   ControlSizeFlags = 3
	ControlSizeFill         ControlSizeFlags = 1
	ControlSizeShrinkCenter ControlSizeFlags = 4
	ControlSizeShrinkEnd    ControlSizeFlags = 8
)

//func NewControlFromPointer(ptr gdnative.Pointer) Control {
func newControlFromPointer(ptr gdnative.Pointer) Control {
	owner := gdnative.NewObjectFromPointer(ptr)
	obj := Control{}
	obj.SetBaseObject(owner)

	return obj
}

/*
Base class for all User Interface or [i]UI[/i] related nodes. [code]Control[/code] features a bounding rectangle that defines its extents, an anchor position relative to its parent and margins that represent an offset to the anchor. The margins update automatically when the node, any of its parents, or the screen size change. For more information on Godot's UI system, anchors, margins, and containers, see the related tutorials in the manual. To build flexible UIs, you'll need a mix of UI elements that inherit from [code]Control[/code] and [Container] nodes. [b]User Interface nodes and input[/b] Godot sends input events to the scene's root node first, by calling [method Node._input]. [method Node._input] forwards the event down the node tree to the nodes under the mouse cursor, or on keyboard focus. To do so, it calls [method MainLoop._input_event]. Call [method accept_event] so no other node receives the event. Once you accepted an input, it becomes handled so [method Node._unhandled_input] will not process it. Only one [code]Control[/code] node can be in keyboard focus. Only the node in focus will receive keyboard events. To get the focus, call [method grab_focus]. [code]Control[/code] nodes lose focus when another node grabs it, or if you hide the node in focus. Set [member mouse_filter] to [constant MOUSE_FILTER_IGNORE] to tell a [code]Control[/code] node to ignore mouse or touch events. You'll need it if you place an icon on top of a button. [Theme] resources change the Control's appearance. If you change the [Theme] on a [code]Control[/code] node, it affects all of its children. To override some of the theme's parameters, call one of the [code]add_*_override[/code] methods, like [method add_font_override]. You can override the theme with the inspector.
*/
type Control struct {
	CanvasItem
	owner gdnative.Object
}

func (o *Control) BaseClass() string {
	return "Control"
}

/*

	Args: [], Returns: bool
*/
func (o *Control) X_ClipsInput() gdnative.Bool {
	//log.Println("Calling Control.X_ClipsInput()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 0, 0)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Control", "_clips_input")

	// Call the parent method.
	// bool
	retPtr := gdnative.NewEmptyBool()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := gdnative.NewBoolFromPointer(retPtr)
	return ret
}

/*
        Returns the minimum size for this control. See [member rect_min_size].
	Args: [], Returns: Vector2
*/
func (o *Control) X_GetMinimumSize() gdnative.Vector2 {
	//log.Println("Calling Control.X_GetMinimumSize()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 0, 0)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Control", "_get_minimum_size")

	// Call the parent method.
	// Vector2
	retPtr := gdnative.NewEmptyVector2()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := gdnative.NewVector2FromPointer(retPtr)
	return ret
}

/*
        Undocumented
	Args: [], Returns: String
*/
func (o *Control) X_GetTooltip() gdnative.String {
	//log.Println("Calling Control.X_GetTooltip()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 0, 0)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Control", "_get_tooltip")

	// Call the parent method.
	// String
	retPtr := gdnative.NewEmptyString()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := gdnative.NewStringFromPointer(retPtr)
	return ret
}

/*
        Use this method to process and accept inputs on UI elements. See [method accept_event]. Replaces Godot 2's [code]_input_event[/code].
	Args: [{ false event InputEvent}], Returns: void
*/
func (o *Control) X_GuiInput(event InputEventImplementer) {
	//log.Println("Calling Control.X_GuiInput()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 1, 1)
	ptrArguments[0] = gdnative.NewPointerFromObject(event.GetBaseObject())

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Control", "_gui_input")

	// Call the parent method.
	// void
	retPtr := gdnative.NewEmptyVoid()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

}

/*

	Args: [{ false for_text String}], Returns: Object
*/
func (o *Control) X_MakeCustomTooltip(forText gdnative.String) ObjectImplementer {
	//log.Println("Calling Control.X_MakeCustomTooltip()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 1, 1)
	ptrArguments[0] = gdnative.NewPointerFromString(forText)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Control", "_make_custom_tooltip")

	// Call the parent method.
	// Object
	retPtr := gdnative.NewEmptyObject()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := newObjectFromPointer(retPtr)

	// Check to see if we already have an instance of this object in our Go instance registry.
	if instance, ok := InstanceRegistry.Get(ret.GetBaseObject().ID()); ok {
		return instance.(ObjectImplementer)
	}

	// Check to see what kind of class this is and create it. This is generally used with
	// GetNode().
	className := ret.GetClass()
	if className != "Object" {
		actualRet := getActualClass(className, ret.GetBaseObject())
		return actualRet.(ObjectImplementer)
	}

	return &ret
}

/*
        Undocumented
	Args: [], Returns: void
*/
func (o *Control) X_OverrideChanged() {
	//log.Println("Calling Control.X_OverrideChanged()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 0, 0)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Control", "_override_changed")

	// Call the parent method.
	// void
	retPtr := gdnative.NewEmptyVoid()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

}

/*
        Undocumented
	Args: [{ false margin int} { false anchor float}], Returns: void
*/
func (o *Control) X_SetAnchor(margin gdnative.Int, anchor gdnative.Real) {
	//log.Println("Calling Control.X_SetAnchor()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 2, 2)
	ptrArguments[0] = gdnative.NewPointerFromInt(margin)
	ptrArguments[1] = gdnative.NewPointerFromReal(anchor)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Control", "_set_anchor")

	// Call the parent method.
	// void
	retPtr := gdnative.NewEmptyVoid()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

}

/*
        Undocumented
	Args: [], Returns: void
*/
func (o *Control) X_SizeChanged() {
	//log.Println("Calling Control.X_SizeChanged()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 0, 0)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Control", "_size_changed")

	// Call the parent method.
	// void
	retPtr := gdnative.NewEmptyVoid()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

}

/*
        Undocumented
	Args: [], Returns: void
*/
func (o *Control) X_ThemeChanged() {
	//log.Println("Calling Control.X_ThemeChanged()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 0, 0)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Control", "_theme_changed")

	// Call the parent method.
	// void
	retPtr := gdnative.NewEmptyVoid()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

}

/*
        Undocumented
	Args: [], Returns: void
*/
func (o *Control) X_UpdateMinimumSize() {
	//log.Println("Calling Control.X_UpdateMinimumSize()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 0, 0)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Control", "_update_minimum_size")

	// Call the parent method.
	// void
	retPtr := gdnative.NewEmptyVoid()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

}

/*
        Marks an input event as handled. Once you accept an input event, it stops propagating, even to nodes listening to [method Node._unhandled_input] or [method Node._unhandled_key_input].
	Args: [], Returns: void
*/
func (o *Control) AcceptEvent() {
	//log.Println("Calling Control.AcceptEvent()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 0, 0)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Control", "accept_event")

	// Call the parent method.
	// void
	retPtr := gdnative.NewEmptyVoid()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

}

/*
        Overrides the color in the [member theme] resource the node uses.
	Args: [{ false name String} { false color Color}], Returns: void
*/
func (o *Control) AddColorOverride(name gdnative.String, color gdnative.Color) {
	//log.Println("Calling Control.AddColorOverride()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 2, 2)
	ptrArguments[0] = gdnative.NewPointerFromString(name)
	ptrArguments[1] = gdnative.NewPointerFromColor(color)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Control", "add_color_override")

	// Call the parent method.
	// void
	retPtr := gdnative.NewEmptyVoid()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

}

/*
        Overrides an integer constant in the [member theme] resource the node uses. If the [code]constant[/code] is invalid, Godot clears the override.
	Args: [{ false name String} { false constant int}], Returns: void
*/
func (o *Control) AddConstantOverride(name gdnative.String, constant gdnative.Int) {
	//log.Println("Calling Control.AddConstantOverride()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 2, 2)
	ptrArguments[0] = gdnative.NewPointerFromString(name)
	ptrArguments[1] = gdnative.NewPointerFromInt(constant)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Control", "add_constant_override")

	// Call the parent method.
	// void
	retPtr := gdnative.NewEmptyVoid()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

}

/*
        Overrides the [code]name[/code] font in the [member theme] resource the node uses. If [code]font[/code] is empty, Godot clears the override.
	Args: [{ false name String} { false font Font}], Returns: void
*/
func (o *Control) AddFontOverride(name gdnative.String, font FontImplementer) {
	//log.Println("Calling Control.AddFontOverride()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 2, 2)
	ptrArguments[0] = gdnative.NewPointerFromString(name)
	ptrArguments[1] = gdnative.NewPointerFromObject(font.GetBaseObject())

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Control", "add_font_override")

	// Call the parent method.
	// void
	retPtr := gdnative.NewEmptyVoid()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

}

/*
        Overrides the [code]name[/code] icon in the [member theme] resource the node uses. If [code]icon[/code] is empty, Godot clears the override.
	Args: [{ false name String} { false texture Texture}], Returns: void
*/
func (o *Control) AddIconOverride(name gdnative.String, texture TextureImplementer) {
	//log.Println("Calling Control.AddIconOverride()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 2, 2)
	ptrArguments[0] = gdnative.NewPointerFromString(name)
	ptrArguments[1] = gdnative.NewPointerFromObject(texture.GetBaseObject())

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Control", "add_icon_override")

	// Call the parent method.
	// void
	retPtr := gdnative.NewEmptyVoid()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

}

/*
        Overrides the [code]name[/code] shader in the [member theme] resource the node uses. If [code]shader[/code] is empty, Godot clears the override.
	Args: [{ false name String} { false shader Shader}], Returns: void
*/
func (o *Control) AddShaderOverride(name gdnative.String, shader ShaderImplementer) {
	//log.Println("Calling Control.AddShaderOverride()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 2, 2)
	ptrArguments[0] = gdnative.NewPointerFromString(name)
	ptrArguments[1] = gdnative.NewPointerFromObject(shader.GetBaseObject())

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Control", "add_shader_override")

	// Call the parent method.
	// void
	retPtr := gdnative.NewEmptyVoid()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

}

/*
        Overrides the [code]name[/code] [StyleBox] in the [member theme] resource the node uses. If [code]stylebox[/code] is empty, Godot clears the override.
	Args: [{ false name String} { false stylebox StyleBox}], Returns: void
*/
func (o *Control) AddStyleboxOverride(name gdnative.String, stylebox StyleBoxImplementer) {
	//log.Println("Calling Control.AddStyleboxOverride()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 2, 2)
	ptrArguments[0] = gdnative.NewPointerFromString(name)
	ptrArguments[1] = gdnative.NewPointerFromObject(stylebox.GetBaseObject())

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Control", "add_stylebox_override")

	// Call the parent method.
	// void
	retPtr := gdnative.NewEmptyVoid()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

}

/*
        Godot calls this method to test if [code]data[/code] from a control's [method get_drag_data] can be dropped at [code]position[/code]. [code]position[/code] is local to this control. This method should only be used to test the data. Process the data in [method drop_data]. [codeblock] extends Control func can_drop_data(position, data): # check position if it is relevant to you # otherwise just check data return typeof(data) == TYPE_DICTIONARY and data.has('expected') [/codeblock]
	Args: [{ false position Vector2} { false data Variant}], Returns: bool
*/
func (o *Control) CanDropData(position gdnative.Vector2, data gdnative.Variant) gdnative.Bool {
	//log.Println("Calling Control.CanDropData()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 2, 2)
	ptrArguments[0] = gdnative.NewPointerFromVector2(position)
	ptrArguments[1] = gdnative.NewPointerFromVariant(data)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Control", "can_drop_data")

	// Call the parent method.
	// bool
	retPtr := gdnative.NewEmptyBool()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := gdnative.NewBoolFromPointer(retPtr)
	return ret
}

/*
        Godot calls this method to pass you the [code]data[/code] from a control's [method get_drag_data] result. Godot first calls [method can_drop_data] to test if [code]data[/code] is allowed to drop at [code]position[/code] where [code]position[/code] is local to this control. [codeblock] extends ColorRect func can_drop_data(position, data): return typeof(data) == TYPE_DICTIONARY and data.has('color') func drop_data(position, data): color = data['color'] [/codeblock]
	Args: [{ false position Vector2} { false data Variant}], Returns: void
*/
func (o *Control) DropData(position gdnative.Vector2, data gdnative.Variant) {
	//log.Println("Calling Control.DropData()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 2, 2)
	ptrArguments[0] = gdnative.NewPointerFromVector2(position)
	ptrArguments[1] = gdnative.NewPointerFromVariant(data)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Control", "drop_data")

	// Call the parent method.
	// void
	retPtr := gdnative.NewEmptyVoid()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

}

/*
        Forces drag and bypasses [method get_drag_data] and [method set_drag_preview] by passing [code]data[/code] and [code]preview[/code]. Drag will start even if the mouse is neither over nor pressed on this control. The methods [method can_drop_data] and [method drop_data] must be implemented on controls that want to receive drop data.
	Args: [{ false data Variant} { false preview Object}], Returns: void
*/
func (o *Control) ForceDrag(data gdnative.Variant, preview ObjectImplementer) {
	//log.Println("Calling Control.ForceDrag()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 2, 2)
	ptrArguments[0] = gdnative.NewPointerFromVariant(data)
	ptrArguments[1] = gdnative.NewPointerFromObject(preview.GetBaseObject())

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Control", "force_drag")

	// Call the parent method.
	// void
	retPtr := gdnative.NewEmptyVoid()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

}

/*
        Undocumented
	Args: [{ false margin int}], Returns: float
*/
func (o *Control) GetAnchor(margin gdnative.Int) gdnative.Real {
	//log.Println("Calling Control.GetAnchor()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 1, 1)
	ptrArguments[0] = gdnative.NewPointerFromInt(margin)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Control", "get_anchor")

	// Call the parent method.
	// float
	retPtr := gdnative.NewEmptyReal()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := gdnative.NewRealFromPointer(retPtr)
	return ret
}

/*
        Returns [member margin_left] and [member margin_top]. See also [member rect_position].
	Args: [], Returns: Vector2
*/
func (o *Control) GetBegin() gdnative.Vector2 {
	//log.Println("Calling Control.GetBegin()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 0, 0)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Control", "get_begin")

	// Call the parent method.
	// Vector2
	retPtr := gdnative.NewEmptyVector2()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := gdnative.NewVector2FromPointer(retPtr)
	return ret
}

/*

	Args: [{ false name String} { true type String}], Returns: Color
*/
func (o *Control) GetColor(name gdnative.String, aType gdnative.String) gdnative.Color {
	//log.Println("Calling Control.GetColor()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 2, 2)
	ptrArguments[0] = gdnative.NewPointerFromString(name)
	ptrArguments[1] = gdnative.NewPointerFromString(aType)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Control", "get_color")

	// Call the parent method.
	// Color
	retPtr := gdnative.NewEmptyColor()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := gdnative.NewColorFromPointer(retPtr)
	return ret
}

/*

	Args: [], Returns: Vector2
*/
func (o *Control) GetCombinedMinimumSize() gdnative.Vector2 {
	//log.Println("Calling Control.GetCombinedMinimumSize()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 0, 0)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Control", "get_combined_minimum_size")

	// Call the parent method.
	// Vector2
	retPtr := gdnative.NewEmptyVector2()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := gdnative.NewVector2FromPointer(retPtr)
	return ret
}

/*

	Args: [{ false name String} { true type String}], Returns: int
*/
func (o *Control) GetConstant(name gdnative.String, aType gdnative.String) gdnative.Int {
	//log.Println("Calling Control.GetConstant()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 2, 2)
	ptrArguments[0] = gdnative.NewPointerFromString(name)
	ptrArguments[1] = gdnative.NewPointerFromString(aType)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Control", "get_constant")

	// Call the parent method.
	// int
	retPtr := gdnative.NewEmptyInt()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := gdnative.NewIntFromPointer(retPtr)
	return ret
}

/*
        Returns the mouse cursor shape the control displays on mouse hover. See [enum CursorShape].
	Args: [{(0, 0) true position Vector2}], Returns: enum.Control::CursorShape
*/
func (o *Control) GetCursorShape(position gdnative.Vector2) ControlCursorShape {
	//log.Println("Calling Control.GetCursorShape()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 1, 1)
	ptrArguments[0] = gdnative.NewPointerFromVector2(position)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Control", "get_cursor_shape")

	// Call the parent method.
	// enum.Control::CursorShape
	retPtr := gdnative.NewEmptyInt()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := gdnative.NewIntFromPointer(retPtr)
	return ControlCursorShape(ret)
}

/*
        Undocumented
	Args: [], Returns: Vector2
*/
func (o *Control) GetCustomMinimumSize() gdnative.Vector2 {
	//log.Println("Calling Control.GetCustomMinimumSize()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 0, 0)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Control", "get_custom_minimum_size")

	// Call the parent method.
	// Vector2
	retPtr := gdnative.NewEmptyVector2()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := gdnative.NewVector2FromPointer(retPtr)
	return ret
}

/*
        Undocumented
	Args: [], Returns: enum.Control::CursorShape
*/
func (o *Control) GetDefaultCursorShape() ControlCursorShape {
	//log.Println("Calling Control.GetDefaultCursorShape()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 0, 0)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Control", "get_default_cursor_shape")

	// Call the parent method.
	// enum.Control::CursorShape
	retPtr := gdnative.NewEmptyInt()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := gdnative.NewIntFromPointer(retPtr)
	return ControlCursorShape(ret)
}

/*
        Godot calls this method to get data that can be dragged and dropped onto controls that expect drop data. Return null if there is no data to drag. Controls that want to receive drop data should implement [method can_drop_data] and [method drop_data]. [code]position[/code] is local to this control. Drag may be forced with [method force_drag]. A preview that will follow the mouse that should represent the data can be set with [method set_drag_preview]. A good time to set the preview is in this method. [codeblock] extends Control func get_drag_data(position): var mydata = make_data() set_drag_preview(make_preview(mydata)) return mydata [/codeblock]
	Args: [{ false position Vector2}], Returns: Object
*/
func (o *Control) GetDragData(position gdnative.Vector2) ObjectImplementer {
	//log.Println("Calling Control.GetDragData()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 1, 1)
	ptrArguments[0] = gdnative.NewPointerFromVector2(position)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Control", "get_drag_data")

	// Call the parent method.
	// Object
	retPtr := gdnative.NewEmptyObject()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := newObjectFromPointer(retPtr)

	// Check to see if we already have an instance of this object in our Go instance registry.
	if instance, ok := InstanceRegistry.Get(ret.GetBaseObject().ID()); ok {
		return instance.(ObjectImplementer)
	}

	// Check to see what kind of class this is and create it. This is generally used with
	// GetNode().
	className := ret.GetClass()
	if className != "Object" {
		actualRet := getActualClass(className, ret.GetBaseObject())
		return actualRet.(ObjectImplementer)
	}

	return &ret
}

/*
        Returns [member margin_right] and [member margin_bottom].
	Args: [], Returns: Vector2
*/
func (o *Control) GetEnd() gdnative.Vector2 {
	//log.Println("Calling Control.GetEnd()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 0, 0)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Control", "get_end")

	// Call the parent method.
	// Vector2
	retPtr := gdnative.NewEmptyVector2()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := gdnative.NewVector2FromPointer(retPtr)
	return ret
}

/*
        Undocumented
	Args: [], Returns: enum.Control::FocusMode
*/
func (o *Control) GetFocusMode() ControlFocusMode {
	//log.Println("Calling Control.GetFocusMode()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 0, 0)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Control", "get_focus_mode")

	// Call the parent method.
	// enum.Control::FocusMode
	retPtr := gdnative.NewEmptyInt()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := gdnative.NewIntFromPointer(retPtr)
	return ControlFocusMode(ret)
}

/*
        Undocumented
	Args: [{ false margin int}], Returns: NodePath
*/
func (o *Control) GetFocusNeighbour(margin gdnative.Int) gdnative.NodePath {
	//log.Println("Calling Control.GetFocusNeighbour()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 1, 1)
	ptrArguments[0] = gdnative.NewPointerFromInt(margin)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Control", "get_focus_neighbour")

	// Call the parent method.
	// NodePath
	retPtr := gdnative.NewEmptyNodePath()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := gdnative.NewNodePathFromPointer(retPtr)
	return ret
}

/*
        Undocumented
	Args: [], Returns: NodePath
*/
func (o *Control) GetFocusNext() gdnative.NodePath {
	//log.Println("Calling Control.GetFocusNext()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 0, 0)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Control", "get_focus_next")

	// Call the parent method.
	// NodePath
	retPtr := gdnative.NewEmptyNodePath()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := gdnative.NewNodePathFromPointer(retPtr)
	return ret
}

/*
        Returns the control that has the keyboard focus or [code]null[/code] if none.
	Args: [], Returns: Control
*/
func (o *Control) GetFocusOwner() ControlImplementer {
	//log.Println("Calling Control.GetFocusOwner()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 0, 0)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Control", "get_focus_owner")

	// Call the parent method.
	// Control
	retPtr := gdnative.NewEmptyObject()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := newControlFromPointer(retPtr)

	// Check to see if we already have an instance of this object in our Go instance registry.
	if instance, ok := InstanceRegistry.Get(ret.GetBaseObject().ID()); ok {
		return instance.(ControlImplementer)
	}

	// Check to see what kind of class this is and create it. This is generally used with
	// GetNode().
	className := ret.GetClass()
	if className != "Control" {
		actualRet := getActualClass(className, ret.GetBaseObject())
		return actualRet.(ControlImplementer)
	}

	return &ret
}

/*
        Undocumented
	Args: [], Returns: NodePath
*/
func (o *Control) GetFocusPrevious() gdnative.NodePath {
	//log.Println("Calling Control.GetFocusPrevious()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 0, 0)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Control", "get_focus_previous")

	// Call the parent method.
	// NodePath
	retPtr := gdnative.NewEmptyNodePath()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := gdnative.NewNodePathFromPointer(retPtr)
	return ret
}

/*

	Args: [{ false name String} { true type String}], Returns: Font
*/
func (o *Control) GetFont(name gdnative.String, aType gdnative.String) FontImplementer {
	//log.Println("Calling Control.GetFont()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 2, 2)
	ptrArguments[0] = gdnative.NewPointerFromString(name)
	ptrArguments[1] = gdnative.NewPointerFromString(aType)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Control", "get_font")

	// Call the parent method.
	// Font
	retPtr := gdnative.NewEmptyObject()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := newFontFromPointer(retPtr)

	// Check to see if we already have an instance of this object in our Go instance registry.
	if instance, ok := InstanceRegistry.Get(ret.GetBaseObject().ID()); ok {
		return instance.(FontImplementer)
	}

	// Check to see what kind of class this is and create it. This is generally used with
	// GetNode().
	className := ret.GetClass()
	if className != "Font" {
		actualRet := getActualClass(className, ret.GetBaseObject())
		return actualRet.(FontImplementer)
	}

	return &ret
}

/*
        Undocumented
	Args: [], Returns: Vector2
*/
func (o *Control) GetGlobalPosition() gdnative.Vector2 {
	//log.Println("Calling Control.GetGlobalPosition()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 0, 0)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Control", "get_global_position")

	// Call the parent method.
	// Vector2
	retPtr := gdnative.NewEmptyVector2()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := gdnative.NewVector2FromPointer(retPtr)
	return ret
}

/*
        Returns the position and size of the control relative to the top-left corner of the screen. See [member rect_position] and [member rect_size].
	Args: [], Returns: Rect2
*/
func (o *Control) GetGlobalRect() gdnative.Rect2 {
	//log.Println("Calling Control.GetGlobalRect()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 0, 0)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Control", "get_global_rect")

	// Call the parent method.
	// Rect2
	retPtr := gdnative.NewEmptyRect2()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := gdnative.NewRect2FromPointer(retPtr)
	return ret
}

/*
        Undocumented
	Args: [], Returns: enum.Control::GrowDirection
*/
func (o *Control) GetHGrowDirection() ControlGrowDirection {
	//log.Println("Calling Control.GetHGrowDirection()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 0, 0)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Control", "get_h_grow_direction")

	// Call the parent method.
	// enum.Control::GrowDirection
	retPtr := gdnative.NewEmptyInt()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := gdnative.NewIntFromPointer(retPtr)
	return ControlGrowDirection(ret)
}

/*
        Undocumented
	Args: [], Returns: int
*/
func (o *Control) GetHSizeFlags() gdnative.Int {
	//log.Println("Calling Control.GetHSizeFlags()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 0, 0)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Control", "get_h_size_flags")

	// Call the parent method.
	// int
	retPtr := gdnative.NewEmptyInt()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := gdnative.NewIntFromPointer(retPtr)
	return ret
}

/*

	Args: [{ false name String} { true type String}], Returns: Texture
*/
func (o *Control) GetIcon(name gdnative.String, aType gdnative.String) TextureImplementer {
	//log.Println("Calling Control.GetIcon()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 2, 2)
	ptrArguments[0] = gdnative.NewPointerFromString(name)
	ptrArguments[1] = gdnative.NewPointerFromString(aType)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Control", "get_icon")

	// Call the parent method.
	// Texture
	retPtr := gdnative.NewEmptyObject()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := newTextureFromPointer(retPtr)

	// Check to see if we already have an instance of this object in our Go instance registry.
	if instance, ok := InstanceRegistry.Get(ret.GetBaseObject().ID()); ok {
		return instance.(TextureImplementer)
	}

	// Check to see what kind of class this is and create it. This is generally used with
	// GetNode().
	className := ret.GetClass()
	if className != "Texture" {
		actualRet := getActualClass(className, ret.GetBaseObject())
		return actualRet.(TextureImplementer)
	}

	return &ret
}

/*
        Undocumented
	Args: [{ false margin int}], Returns: float
*/
func (o *Control) GetMargin(margin gdnative.Int) gdnative.Real {
	//log.Println("Calling Control.GetMargin()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 1, 1)
	ptrArguments[0] = gdnative.NewPointerFromInt(margin)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Control", "get_margin")

	// Call the parent method.
	// float
	retPtr := gdnative.NewEmptyReal()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := gdnative.NewRealFromPointer(retPtr)
	return ret
}

/*
        Returns the minimum size for this control. See [member rect_min_size].
	Args: [], Returns: Vector2
*/
func (o *Control) GetMinimumSize() gdnative.Vector2 {
	//log.Println("Calling Control.GetMinimumSize()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 0, 0)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Control", "get_minimum_size")

	// Call the parent method.
	// Vector2
	retPtr := gdnative.NewEmptyVector2()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := gdnative.NewVector2FromPointer(retPtr)
	return ret
}

/*
        Undocumented
	Args: [], Returns: enum.Control::MouseFilter
*/
func (o *Control) GetMouseFilter() ControlMouseFilter {
	//log.Println("Calling Control.GetMouseFilter()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 0, 0)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Control", "get_mouse_filter")

	// Call the parent method.
	// enum.Control::MouseFilter
	retPtr := gdnative.NewEmptyInt()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := gdnative.NewIntFromPointer(retPtr)
	return ControlMouseFilter(ret)
}

/*
        Returns the width/height occupied in the parent control.
	Args: [], Returns: Vector2
*/
func (o *Control) GetParentAreaSize() gdnative.Vector2 {
	//log.Println("Calling Control.GetParentAreaSize()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 0, 0)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Control", "get_parent_area_size")

	// Call the parent method.
	// Vector2
	retPtr := gdnative.NewEmptyVector2()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := gdnative.NewVector2FromPointer(retPtr)
	return ret
}

/*
        Returns the parent control node.
	Args: [], Returns: Control
*/
func (o *Control) GetParentControl() ControlImplementer {
	//log.Println("Calling Control.GetParentControl()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 0, 0)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Control", "get_parent_control")

	// Call the parent method.
	// Control
	retPtr := gdnative.NewEmptyObject()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := newControlFromPointer(retPtr)

	// Check to see if we already have an instance of this object in our Go instance registry.
	if instance, ok := InstanceRegistry.Get(ret.GetBaseObject().ID()); ok {
		return instance.(ControlImplementer)
	}

	// Check to see what kind of class this is and create it. This is generally used with
	// GetNode().
	className := ret.GetClass()
	if className != "Control" {
		actualRet := getActualClass(className, ret.GetBaseObject())
		return actualRet.(ControlImplementer)
	}

	return &ret
}

/*
        Undocumented
	Args: [], Returns: Vector2
*/
func (o *Control) GetPivotOffset() gdnative.Vector2 {
	//log.Println("Calling Control.GetPivotOffset()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 0, 0)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Control", "get_pivot_offset")

	// Call the parent method.
	// Vector2
	retPtr := gdnative.NewEmptyVector2()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := gdnative.NewVector2FromPointer(retPtr)
	return ret
}

/*
        Undocumented
	Args: [], Returns: Vector2
*/
func (o *Control) GetPosition() gdnative.Vector2 {
	//log.Println("Calling Control.GetPosition()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 0, 0)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Control", "get_position")

	// Call the parent method.
	// Vector2
	retPtr := gdnative.NewEmptyVector2()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := gdnative.NewVector2FromPointer(retPtr)
	return ret
}

/*
        Returns the position and size of the control relative to the top-left corner of the parent Control. See [member rect_position] and [member rect_size].
	Args: [], Returns: Rect2
*/
func (o *Control) GetRect() gdnative.Rect2 {
	//log.Println("Calling Control.GetRect()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 0, 0)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Control", "get_rect")

	// Call the parent method.
	// Rect2
	retPtr := gdnative.NewEmptyRect2()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := gdnative.NewRect2FromPointer(retPtr)
	return ret
}

/*
        Returns the rotation (in radians).
	Args: [], Returns: float
*/
func (o *Control) GetRotation() gdnative.Real {
	//log.Println("Calling Control.GetRotation()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 0, 0)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Control", "get_rotation")

	// Call the parent method.
	// float
	retPtr := gdnative.NewEmptyReal()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := gdnative.NewRealFromPointer(retPtr)
	return ret
}

/*
        Undocumented
	Args: [], Returns: float
*/
func (o *Control) GetRotationDegrees() gdnative.Real {
	//log.Println("Calling Control.GetRotationDegrees()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 0, 0)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Control", "get_rotation_degrees")

	// Call the parent method.
	// float
	retPtr := gdnative.NewEmptyReal()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := gdnative.NewRealFromPointer(retPtr)
	return ret
}

/*
        Undocumented
	Args: [], Returns: Vector2
*/
func (o *Control) GetScale() gdnative.Vector2 {
	//log.Println("Calling Control.GetScale()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 0, 0)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Control", "get_scale")

	// Call the parent method.
	// Vector2
	retPtr := gdnative.NewEmptyVector2()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := gdnative.NewVector2FromPointer(retPtr)
	return ret
}

/*
        Undocumented
	Args: [], Returns: Vector2
*/
func (o *Control) GetSize() gdnative.Vector2 {
	//log.Println("Calling Control.GetSize()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 0, 0)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Control", "get_size")

	// Call the parent method.
	// Vector2
	retPtr := gdnative.NewEmptyVector2()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := gdnative.NewVector2FromPointer(retPtr)
	return ret
}

/*
        Undocumented
	Args: [], Returns: float
*/
func (o *Control) GetStretchRatio() gdnative.Real {
	//log.Println("Calling Control.GetStretchRatio()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 0, 0)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Control", "get_stretch_ratio")

	// Call the parent method.
	// float
	retPtr := gdnative.NewEmptyReal()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := gdnative.NewRealFromPointer(retPtr)
	return ret
}

/*

	Args: [{ false name String} { true type String}], Returns: StyleBox
*/
func (o *Control) GetStylebox(name gdnative.String, aType gdnative.String) StyleBoxImplementer {
	//log.Println("Calling Control.GetStylebox()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 2, 2)
	ptrArguments[0] = gdnative.NewPointerFromString(name)
	ptrArguments[1] = gdnative.NewPointerFromString(aType)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Control", "get_stylebox")

	// Call the parent method.
	// StyleBox
	retPtr := gdnative.NewEmptyObject()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := newStyleBoxFromPointer(retPtr)

	// Check to see if we already have an instance of this object in our Go instance registry.
	if instance, ok := InstanceRegistry.Get(ret.GetBaseObject().ID()); ok {
		return instance.(StyleBoxImplementer)
	}

	// Check to see what kind of class this is and create it. This is generally used with
	// GetNode().
	className := ret.GetClass()
	if className != "StyleBox" {
		actualRet := getActualClass(className, ret.GetBaseObject())
		return actualRet.(StyleBoxImplementer)
	}

	return &ret
}

/*
        Undocumented
	Args: [], Returns: Theme
*/
func (o *Control) GetTheme() ThemeImplementer {
	//log.Println("Calling Control.GetTheme()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 0, 0)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Control", "get_theme")

	// Call the parent method.
	// Theme
	retPtr := gdnative.NewEmptyObject()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := newThemeFromPointer(retPtr)

	// Check to see if we already have an instance of this object in our Go instance registry.
	if instance, ok := InstanceRegistry.Get(ret.GetBaseObject().ID()); ok {
		return instance.(ThemeImplementer)
	}

	// Check to see what kind of class this is and create it. This is generally used with
	// GetNode().
	className := ret.GetClass()
	if className != "Theme" {
		actualRet := getActualClass(className, ret.GetBaseObject())
		return actualRet.(ThemeImplementer)
	}

	return &ret
}

/*
        Returns the tooltip, which will appear when the cursor is resting over this control.
	Args: [{(0, 0) true at_position Vector2}], Returns: String
*/
func (o *Control) GetTooltip(atPosition gdnative.Vector2) gdnative.String {
	//log.Println("Calling Control.GetTooltip()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 1, 1)
	ptrArguments[0] = gdnative.NewPointerFromVector2(atPosition)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Control", "get_tooltip")

	// Call the parent method.
	// String
	retPtr := gdnative.NewEmptyString()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := gdnative.NewStringFromPointer(retPtr)
	return ret
}

/*
        Undocumented
	Args: [], Returns: enum.Control::GrowDirection
*/
func (o *Control) GetVGrowDirection() ControlGrowDirection {
	//log.Println("Calling Control.GetVGrowDirection()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 0, 0)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Control", "get_v_grow_direction")

	// Call the parent method.
	// enum.Control::GrowDirection
	retPtr := gdnative.NewEmptyInt()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := gdnative.NewIntFromPointer(retPtr)
	return ControlGrowDirection(ret)
}

/*
        Undocumented
	Args: [], Returns: int
*/
func (o *Control) GetVSizeFlags() gdnative.Int {
	//log.Println("Calling Control.GetVSizeFlags()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 0, 0)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Control", "get_v_size_flags")

	// Call the parent method.
	// int
	retPtr := gdnative.NewEmptyInt()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := gdnative.NewIntFromPointer(retPtr)
	return ret
}

/*

	Args: [], Returns: void
*/
func (o *Control) GrabClickFocus() {
	//log.Println("Calling Control.GrabClickFocus()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 0, 0)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Control", "grab_click_focus")

	// Call the parent method.
	// void
	retPtr := gdnative.NewEmptyVoid()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

}

/*
        Steal the focus from another control and become the focused control (see [member focus_mode]).
	Args: [], Returns: void
*/
func (o *Control) GrabFocus() {
	//log.Println("Calling Control.GrabFocus()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 0, 0)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Control", "grab_focus")

	// Call the parent method.
	// void
	retPtr := gdnative.NewEmptyVoid()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

}

/*

	Args: [{ false name String} { true type String}], Returns: bool
*/
func (o *Control) HasColor(name gdnative.String, aType gdnative.String) gdnative.Bool {
	//log.Println("Calling Control.HasColor()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 2, 2)
	ptrArguments[0] = gdnative.NewPointerFromString(name)
	ptrArguments[1] = gdnative.NewPointerFromString(aType)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Control", "has_color")

	// Call the parent method.
	// bool
	retPtr := gdnative.NewEmptyBool()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := gdnative.NewBoolFromPointer(retPtr)
	return ret
}

/*

	Args: [{ false name String}], Returns: bool
*/
func (o *Control) HasColorOverride(name gdnative.String) gdnative.Bool {
	//log.Println("Calling Control.HasColorOverride()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 1, 1)
	ptrArguments[0] = gdnative.NewPointerFromString(name)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Control", "has_color_override")

	// Call the parent method.
	// bool
	retPtr := gdnative.NewEmptyBool()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := gdnative.NewBoolFromPointer(retPtr)
	return ret
}

/*

	Args: [{ false name String} { true type String}], Returns: bool
*/
func (o *Control) HasConstant(name gdnative.String, aType gdnative.String) gdnative.Bool {
	//log.Println("Calling Control.HasConstant()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 2, 2)
	ptrArguments[0] = gdnative.NewPointerFromString(name)
	ptrArguments[1] = gdnative.NewPointerFromString(aType)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Control", "has_constant")

	// Call the parent method.
	// bool
	retPtr := gdnative.NewEmptyBool()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := gdnative.NewBoolFromPointer(retPtr)
	return ret
}

/*

	Args: [{ false name String}], Returns: bool
*/
func (o *Control) HasConstantOverride(name gdnative.String) gdnative.Bool {
	//log.Println("Calling Control.HasConstantOverride()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 1, 1)
	ptrArguments[0] = gdnative.NewPointerFromString(name)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Control", "has_constant_override")

	// Call the parent method.
	// bool
	retPtr := gdnative.NewEmptyBool()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := gdnative.NewBoolFromPointer(retPtr)
	return ret
}

/*
        Returns [code]true[/code] if this is the current focused control. See [member focus_mode].
	Args: [], Returns: bool
*/
func (o *Control) HasFocus() gdnative.Bool {
	//log.Println("Calling Control.HasFocus()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 0, 0)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Control", "has_focus")

	// Call the parent method.
	// bool
	retPtr := gdnative.NewEmptyBool()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := gdnative.NewBoolFromPointer(retPtr)
	return ret
}

/*

	Args: [{ false name String} { true type String}], Returns: bool
*/
func (o *Control) HasFont(name gdnative.String, aType gdnative.String) gdnative.Bool {
	//log.Println("Calling Control.HasFont()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 2, 2)
	ptrArguments[0] = gdnative.NewPointerFromString(name)
	ptrArguments[1] = gdnative.NewPointerFromString(aType)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Control", "has_font")

	// Call the parent method.
	// bool
	retPtr := gdnative.NewEmptyBool()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := gdnative.NewBoolFromPointer(retPtr)
	return ret
}

/*

	Args: [{ false name String}], Returns: bool
*/
func (o *Control) HasFontOverride(name gdnative.String) gdnative.Bool {
	//log.Println("Calling Control.HasFontOverride()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 1, 1)
	ptrArguments[0] = gdnative.NewPointerFromString(name)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Control", "has_font_override")

	// Call the parent method.
	// bool
	retPtr := gdnative.NewEmptyBool()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := gdnative.NewBoolFromPointer(retPtr)
	return ret
}

/*

	Args: [{ false name String} { true type String}], Returns: bool
*/
func (o *Control) HasIcon(name gdnative.String, aType gdnative.String) gdnative.Bool {
	//log.Println("Calling Control.HasIcon()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 2, 2)
	ptrArguments[0] = gdnative.NewPointerFromString(name)
	ptrArguments[1] = gdnative.NewPointerFromString(aType)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Control", "has_icon")

	// Call the parent method.
	// bool
	retPtr := gdnative.NewEmptyBool()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := gdnative.NewBoolFromPointer(retPtr)
	return ret
}

/*

	Args: [{ false name String}], Returns: bool
*/
func (o *Control) HasIconOverride(name gdnative.String) gdnative.Bool {
	//log.Println("Calling Control.HasIconOverride()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 1, 1)
	ptrArguments[0] = gdnative.NewPointerFromString(name)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Control", "has_icon_override")

	// Call the parent method.
	// bool
	retPtr := gdnative.NewEmptyBool()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := gdnative.NewBoolFromPointer(retPtr)
	return ret
}

/*

	Args: [{ false point Vector2}], Returns: bool
*/
func (o *Control) HasPoint(point gdnative.Vector2) gdnative.Bool {
	//log.Println("Calling Control.HasPoint()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 1, 1)
	ptrArguments[0] = gdnative.NewPointerFromVector2(point)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Control", "has_point")

	// Call the parent method.
	// bool
	retPtr := gdnative.NewEmptyBool()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := gdnative.NewBoolFromPointer(retPtr)
	return ret
}

/*

	Args: [{ false name String}], Returns: bool
*/
func (o *Control) HasShaderOverride(name gdnative.String) gdnative.Bool {
	//log.Println("Calling Control.HasShaderOverride()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 1, 1)
	ptrArguments[0] = gdnative.NewPointerFromString(name)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Control", "has_shader_override")

	// Call the parent method.
	// bool
	retPtr := gdnative.NewEmptyBool()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := gdnative.NewBoolFromPointer(retPtr)
	return ret
}

/*

	Args: [{ false name String} { true type String}], Returns: bool
*/
func (o *Control) HasStylebox(name gdnative.String, aType gdnative.String) gdnative.Bool {
	//log.Println("Calling Control.HasStylebox()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 2, 2)
	ptrArguments[0] = gdnative.NewPointerFromString(name)
	ptrArguments[1] = gdnative.NewPointerFromString(aType)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Control", "has_stylebox")

	// Call the parent method.
	// bool
	retPtr := gdnative.NewEmptyBool()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := gdnative.NewBoolFromPointer(retPtr)
	return ret
}

/*

	Args: [{ false name String}], Returns: bool
*/
func (o *Control) HasStyleboxOverride(name gdnative.String) gdnative.Bool {
	//log.Println("Calling Control.HasStyleboxOverride()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 1, 1)
	ptrArguments[0] = gdnative.NewPointerFromString(name)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Control", "has_stylebox_override")

	// Call the parent method.
	// bool
	retPtr := gdnative.NewEmptyBool()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := gdnative.NewBoolFromPointer(retPtr)
	return ret
}

/*
        Undocumented
	Args: [], Returns: bool
*/
func (o *Control) IsClippingContents() gdnative.Bool {
	//log.Println("Calling Control.IsClippingContents()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 0, 0)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Control", "is_clipping_contents")

	// Call the parent method.
	// bool
	retPtr := gdnative.NewEmptyBool()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := gdnative.NewBoolFromPointer(retPtr)
	return ret
}

/*

	Args: [], Returns: void
*/
func (o *Control) MinimumSizeChanged() {
	//log.Println("Calling Control.MinimumSizeChanged()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 0, 0)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Control", "minimum_size_changed")

	// Call the parent method.
	// void
	retPtr := gdnative.NewEmptyVoid()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

}

/*
        Give up the focus. No other control will be able to receive keyboard input.
	Args: [], Returns: void
*/
func (o *Control) ReleaseFocus() {
	//log.Println("Calling Control.ReleaseFocus()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 0, 0)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Control", "release_focus")

	// Call the parent method.
	// void
	retPtr := gdnative.NewEmptyVoid()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

}

/*

	Args: [{ false margin int} { false anchor float} {False true keep_margin bool} {True true push_opposite_anchor bool}], Returns: void
*/
func (o *Control) SetAnchor(margin gdnative.Int, anchor gdnative.Real, keepMargin gdnative.Bool, pushOppositeAnchor gdnative.Bool) {
	//log.Println("Calling Control.SetAnchor()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 4, 4)
	ptrArguments[0] = gdnative.NewPointerFromInt(margin)
	ptrArguments[1] = gdnative.NewPointerFromReal(anchor)
	ptrArguments[2] = gdnative.NewPointerFromBool(keepMargin)
	ptrArguments[3] = gdnative.NewPointerFromBool(pushOppositeAnchor)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Control", "set_anchor")

	// Call the parent method.
	// void
	retPtr := gdnative.NewEmptyVoid()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

}

/*

	Args: [{ false margin int} { false anchor float} { false offset float} {False true push_opposite_anchor bool}], Returns: void
*/
func (o *Control) SetAnchorAndMargin(margin gdnative.Int, anchor gdnative.Real, offset gdnative.Real, pushOppositeAnchor gdnative.Bool) {
	//log.Println("Calling Control.SetAnchorAndMargin()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 4, 4)
	ptrArguments[0] = gdnative.NewPointerFromInt(margin)
	ptrArguments[1] = gdnative.NewPointerFromReal(anchor)
	ptrArguments[2] = gdnative.NewPointerFromReal(offset)
	ptrArguments[3] = gdnative.NewPointerFromBool(pushOppositeAnchor)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Control", "set_anchor_and_margin")

	// Call the parent method.
	// void
	retPtr := gdnative.NewEmptyVoid()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

}

/*

	Args: [{ false preset int} {0 true resize_mode int} {0 true margin int}], Returns: void
*/
func (o *Control) SetAnchorsAndMarginsPreset(preset gdnative.Int, resizeMode gdnative.Int, margin gdnative.Int) {
	//log.Println("Calling Control.SetAnchorsAndMarginsPreset()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 3, 3)
	ptrArguments[0] = gdnative.NewPointerFromInt(preset)
	ptrArguments[1] = gdnative.NewPointerFromInt(resizeMode)
	ptrArguments[2] = gdnative.NewPointerFromInt(margin)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Control", "set_anchors_and_margins_preset")

	// Call the parent method.
	// void
	retPtr := gdnative.NewEmptyVoid()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

}

/*

	Args: [{ false preset int} {False true keep_margin bool}], Returns: void
*/
func (o *Control) SetAnchorsPreset(preset gdnative.Int, keepMargin gdnative.Bool) {
	//log.Println("Calling Control.SetAnchorsPreset()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 2, 2)
	ptrArguments[0] = gdnative.NewPointerFromInt(preset)
	ptrArguments[1] = gdnative.NewPointerFromBool(keepMargin)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Control", "set_anchors_preset")

	// Call the parent method.
	// void
	retPtr := gdnative.NewEmptyVoid()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

}

/*
        Sets [member margin_left] and [member margin_top] at the same time.
	Args: [{ false position Vector2}], Returns: void
*/
func (o *Control) SetBegin(position gdnative.Vector2) {
	//log.Println("Calling Control.SetBegin()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 1, 1)
	ptrArguments[0] = gdnative.NewPointerFromVector2(position)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Control", "set_begin")

	// Call the parent method.
	// void
	retPtr := gdnative.NewEmptyVoid()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

}

/*
        Undocumented
	Args: [{ false enable bool}], Returns: void
*/
func (o *Control) SetClipContents(enable gdnative.Bool) {
	//log.Println("Calling Control.SetClipContents()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 1, 1)
	ptrArguments[0] = gdnative.NewPointerFromBool(enable)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Control", "set_clip_contents")

	// Call the parent method.
	// void
	retPtr := gdnative.NewEmptyVoid()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

}

/*
        Undocumented
	Args: [{ false size Vector2}], Returns: void
*/
func (o *Control) SetCustomMinimumSize(size gdnative.Vector2) {
	//log.Println("Calling Control.SetCustomMinimumSize()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 1, 1)
	ptrArguments[0] = gdnative.NewPointerFromVector2(size)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Control", "set_custom_minimum_size")

	// Call the parent method.
	// void
	retPtr := gdnative.NewEmptyVoid()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

}

/*
        Undocumented
	Args: [{ false shape int}], Returns: void
*/
func (o *Control) SetDefaultCursorShape(shape gdnative.Int) {
	//log.Println("Calling Control.SetDefaultCursorShape()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 1, 1)
	ptrArguments[0] = gdnative.NewPointerFromInt(shape)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Control", "set_default_cursor_shape")

	// Call the parent method.
	// void
	retPtr := gdnative.NewEmptyVoid()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

}

/*
        Forwards the handling of this control's drag and drop to [code]target[/code] control. Forwarding can be implemented in the target control similar to the methods [method get_drag_data], [method can_drop_data], and [method drop_data] but with two differences: 1. The function name must be suffixed with [b]_fw[/b] 2. The function must take an extra argument that is the control doing the forwarding [codeblock] # ThisControl.gd extends Control func _ready(): set_drag_forwarding(target_control) # TargetControl.gd extends Control func can_drop_data_fw(position, data, from_control): return true func drop_data_fw(position, data, from_control): my_handle_data(data) func get_drag_data_fw(position, from_control): set_drag_preview(my_preview) return my_data() [/codeblock]
	Args: [{ false target Object}], Returns: void
*/
func (o *Control) SetDragForwarding(target ObjectImplementer) {
	//log.Println("Calling Control.SetDragForwarding()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 1, 1)
	ptrArguments[0] = gdnative.NewPointerFromObject(target.GetBaseObject())

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Control", "set_drag_forwarding")

	// Call the parent method.
	// void
	retPtr := gdnative.NewEmptyVoid()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

}

/*
        Shows the given control at the mouse pointer. A good time to call this method is in [method get_drag_data].
	Args: [{ false control Object}], Returns: void
*/
func (o *Control) SetDragPreview(control ObjectImplementer) {
	//log.Println("Calling Control.SetDragPreview()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 1, 1)
	ptrArguments[0] = gdnative.NewPointerFromObject(control.GetBaseObject())

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Control", "set_drag_preview")

	// Call the parent method.
	// void
	retPtr := gdnative.NewEmptyVoid()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

}

/*
        Sets [member margin_right] and [member margin_bottom] at the same time.
	Args: [{ false position Vector2}], Returns: void
*/
func (o *Control) SetEnd(position gdnative.Vector2) {
	//log.Println("Calling Control.SetEnd()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 1, 1)
	ptrArguments[0] = gdnative.NewPointerFromVector2(position)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Control", "set_end")

	// Call the parent method.
	// void
	retPtr := gdnative.NewEmptyVoid()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

}

/*
        Undocumented
	Args: [{ false mode int}], Returns: void
*/
func (o *Control) SetFocusMode(mode gdnative.Int) {
	//log.Println("Calling Control.SetFocusMode()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 1, 1)
	ptrArguments[0] = gdnative.NewPointerFromInt(mode)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Control", "set_focus_mode")

	// Call the parent method.
	// void
	retPtr := gdnative.NewEmptyVoid()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

}

/*
        Undocumented
	Args: [{ false margin int} { false neighbour NodePath}], Returns: void
*/
func (o *Control) SetFocusNeighbour(margin gdnative.Int, neighbour gdnative.NodePath) {
	//log.Println("Calling Control.SetFocusNeighbour()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 2, 2)
	ptrArguments[0] = gdnative.NewPointerFromInt(margin)
	ptrArguments[1] = gdnative.NewPointerFromNodePath(neighbour)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Control", "set_focus_neighbour")

	// Call the parent method.
	// void
	retPtr := gdnative.NewEmptyVoid()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

}

/*
        Undocumented
	Args: [{ false next NodePath}], Returns: void
*/
func (o *Control) SetFocusNext(next gdnative.NodePath) {
	//log.Println("Calling Control.SetFocusNext()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 1, 1)
	ptrArguments[0] = gdnative.NewPointerFromNodePath(next)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Control", "set_focus_next")

	// Call the parent method.
	// void
	retPtr := gdnative.NewEmptyVoid()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

}

/*
        Undocumented
	Args: [{ false previous NodePath}], Returns: void
*/
func (o *Control) SetFocusPrevious(previous gdnative.NodePath) {
	//log.Println("Calling Control.SetFocusPrevious()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 1, 1)
	ptrArguments[0] = gdnative.NewPointerFromNodePath(previous)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Control", "set_focus_previous")

	// Call the parent method.
	// void
	retPtr := gdnative.NewEmptyVoid()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

}

/*
        Undocumented
	Args: [{ false position Vector2}], Returns: void
*/
func (o *Control) SetGlobalPosition(position gdnative.Vector2) {
	//log.Println("Calling Control.SetGlobalPosition()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 1, 1)
	ptrArguments[0] = gdnative.NewPointerFromVector2(position)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Control", "set_global_position")

	// Call the parent method.
	// void
	retPtr := gdnative.NewEmptyVoid()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

}

/*
        Undocumented
	Args: [{ false direction int}], Returns: void
*/
func (o *Control) SetHGrowDirection(direction gdnative.Int) {
	//log.Println("Calling Control.SetHGrowDirection()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 1, 1)
	ptrArguments[0] = gdnative.NewPointerFromInt(direction)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Control", "set_h_grow_direction")

	// Call the parent method.
	// void
	retPtr := gdnative.NewEmptyVoid()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

}

/*
        Undocumented
	Args: [{ false flags int}], Returns: void
*/
func (o *Control) SetHSizeFlags(flags gdnative.Int) {
	//log.Println("Calling Control.SetHSizeFlags()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 1, 1)
	ptrArguments[0] = gdnative.NewPointerFromInt(flags)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Control", "set_h_size_flags")

	// Call the parent method.
	// void
	retPtr := gdnative.NewEmptyVoid()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

}

/*
        Undocumented
	Args: [{ false margin int} { false offset float}], Returns: void
*/
func (o *Control) SetMargin(margin gdnative.Int, offset gdnative.Real) {
	//log.Println("Calling Control.SetMargin()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 2, 2)
	ptrArguments[0] = gdnative.NewPointerFromInt(margin)
	ptrArguments[1] = gdnative.NewPointerFromReal(offset)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Control", "set_margin")

	// Call the parent method.
	// void
	retPtr := gdnative.NewEmptyVoid()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

}

/*

	Args: [{ false preset int} {0 true resize_mode int} {0 true margin int}], Returns: void
*/
func (o *Control) SetMarginsPreset(preset gdnative.Int, resizeMode gdnative.Int, margin gdnative.Int) {
	//log.Println("Calling Control.SetMarginsPreset()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 3, 3)
	ptrArguments[0] = gdnative.NewPointerFromInt(preset)
	ptrArguments[1] = gdnative.NewPointerFromInt(resizeMode)
	ptrArguments[2] = gdnative.NewPointerFromInt(margin)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Control", "set_margins_preset")

	// Call the parent method.
	// void
	retPtr := gdnative.NewEmptyVoid()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

}

/*
        Undocumented
	Args: [{ false filter int}], Returns: void
*/
func (o *Control) SetMouseFilter(filter gdnative.Int) {
	//log.Println("Calling Control.SetMouseFilter()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 1, 1)
	ptrArguments[0] = gdnative.NewPointerFromInt(filter)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Control", "set_mouse_filter")

	// Call the parent method.
	// void
	retPtr := gdnative.NewEmptyVoid()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

}

/*
        Undocumented
	Args: [{ false pivot_offset Vector2}], Returns: void
*/
func (o *Control) SetPivotOffset(pivotOffset gdnative.Vector2) {
	//log.Println("Calling Control.SetPivotOffset()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 1, 1)
	ptrArguments[0] = gdnative.NewPointerFromVector2(pivotOffset)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Control", "set_pivot_offset")

	// Call the parent method.
	// void
	retPtr := gdnative.NewEmptyVoid()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

}

/*
        Undocumented
	Args: [{ false position Vector2}], Returns: void
*/
func (o *Control) SetPosition(position gdnative.Vector2) {
	//log.Println("Calling Control.SetPosition()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 1, 1)
	ptrArguments[0] = gdnative.NewPointerFromVector2(position)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Control", "set_position")

	// Call the parent method.
	// void
	retPtr := gdnative.NewEmptyVoid()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

}

/*
        Sets the rotation (in radians).
	Args: [{ false radians float}], Returns: void
*/
func (o *Control) SetRotation(radians gdnative.Real) {
	//log.Println("Calling Control.SetRotation()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 1, 1)
	ptrArguments[0] = gdnative.NewPointerFromReal(radians)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Control", "set_rotation")

	// Call the parent method.
	// void
	retPtr := gdnative.NewEmptyVoid()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

}

/*
        Undocumented
	Args: [{ false degrees float}], Returns: void
*/
func (o *Control) SetRotationDegrees(degrees gdnative.Real) {
	//log.Println("Calling Control.SetRotationDegrees()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 1, 1)
	ptrArguments[0] = gdnative.NewPointerFromReal(degrees)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Control", "set_rotation_degrees")

	// Call the parent method.
	// void
	retPtr := gdnative.NewEmptyVoid()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

}

/*
        Undocumented
	Args: [{ false scale Vector2}], Returns: void
*/
func (o *Control) SetScale(scale gdnative.Vector2) {
	//log.Println("Calling Control.SetScale()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 1, 1)
	ptrArguments[0] = gdnative.NewPointerFromVector2(scale)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Control", "set_scale")

	// Call the parent method.
	// void
	retPtr := gdnative.NewEmptyVoid()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

}

/*
        Undocumented
	Args: [{ false size Vector2}], Returns: void
*/
func (o *Control) SetSize(size gdnative.Vector2) {
	//log.Println("Calling Control.SetSize()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 1, 1)
	ptrArguments[0] = gdnative.NewPointerFromVector2(size)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Control", "set_size")

	// Call the parent method.
	// void
	retPtr := gdnative.NewEmptyVoid()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

}

/*
        Undocumented
	Args: [{ false ratio float}], Returns: void
*/
func (o *Control) SetStretchRatio(ratio gdnative.Real) {
	//log.Println("Calling Control.SetStretchRatio()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 1, 1)
	ptrArguments[0] = gdnative.NewPointerFromReal(ratio)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Control", "set_stretch_ratio")

	// Call the parent method.
	// void
	retPtr := gdnative.NewEmptyVoid()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

}

/*
        Undocumented
	Args: [{ false theme Theme}], Returns: void
*/
func (o *Control) SetTheme(theme ThemeImplementer) {
	//log.Println("Calling Control.SetTheme()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 1, 1)
	ptrArguments[0] = gdnative.NewPointerFromObject(theme.GetBaseObject())

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Control", "set_theme")

	// Call the parent method.
	// void
	retPtr := gdnative.NewEmptyVoid()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

}

/*
        Undocumented
	Args: [{ false tooltip String}], Returns: void
*/
func (o *Control) SetTooltip(tooltip gdnative.String) {
	//log.Println("Calling Control.SetTooltip()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 1, 1)
	ptrArguments[0] = gdnative.NewPointerFromString(tooltip)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Control", "set_tooltip")

	// Call the parent method.
	// void
	retPtr := gdnative.NewEmptyVoid()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

}

/*
        Undocumented
	Args: [{ false direction int}], Returns: void
*/
func (o *Control) SetVGrowDirection(direction gdnative.Int) {
	//log.Println("Calling Control.SetVGrowDirection()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 1, 1)
	ptrArguments[0] = gdnative.NewPointerFromInt(direction)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Control", "set_v_grow_direction")

	// Call the parent method.
	// void
	retPtr := gdnative.NewEmptyVoid()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

}

/*
        Undocumented
	Args: [{ false flags int}], Returns: void
*/
func (o *Control) SetVSizeFlags(flags gdnative.Int) {
	//log.Println("Calling Control.SetVSizeFlags()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 1, 1)
	ptrArguments[0] = gdnative.NewPointerFromInt(flags)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Control", "set_v_size_flags")

	// Call the parent method.
	// void
	retPtr := gdnative.NewEmptyVoid()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

}

/*
        Displays a control as modal. Control must be a subwindow. Modal controls capture the input signals until closed or the area outside them is accessed. When a modal control loses focus, or the ESC key is pressed, they automatically hide. Modal controls are used extensively for popup dialogs and menus.
	Args: [{False true exclusive bool}], Returns: void
*/
func (o *Control) ShowModal(exclusive gdnative.Bool) {
	//log.Println("Calling Control.ShowModal()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 1, 1)
	ptrArguments[0] = gdnative.NewPointerFromBool(exclusive)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Control", "show_modal")

	// Call the parent method.
	// void
	retPtr := gdnative.NewEmptyVoid()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

}

/*

	Args: [{ false to_position Vector2}], Returns: void
*/
func (o *Control) WarpMouse(toPosition gdnative.Vector2) {
	//log.Println("Calling Control.WarpMouse()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 1, 1)
	ptrArguments[0] = gdnative.NewPointerFromVector2(toPosition)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Control", "warp_mouse")

	// Call the parent method.
	// void
	retPtr := gdnative.NewEmptyVoid()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

}

// ControlImplementer is an interface that implements the methods
// of the Control class.
type ControlImplementer interface {
	CanvasItemImplementer
	X_ClipsInput() gdnative.Bool
	X_GetMinimumSize() gdnative.Vector2
	X_GetTooltip() gdnative.String
	X_GuiInput(event InputEventImplementer)
	X_MakeCustomTooltip(forText gdnative.String) ObjectImplementer
	X_OverrideChanged()
	X_SetAnchor(margin gdnative.Int, anchor gdnative.Real)
	X_SizeChanged()
	X_ThemeChanged()
	X_UpdateMinimumSize()
	AcceptEvent()
	AddColorOverride(name gdnative.String, color gdnative.Color)
	AddConstantOverride(name gdnative.String, constant gdnative.Int)
	AddFontOverride(name gdnative.String, font FontImplementer)
	AddIconOverride(name gdnative.String, texture TextureImplementer)
	AddShaderOverride(name gdnative.String, shader ShaderImplementer)
	AddStyleboxOverride(name gdnative.String, stylebox StyleBoxImplementer)
	CanDropData(position gdnative.Vector2, data gdnative.Variant) gdnative.Bool
	DropData(position gdnative.Vector2, data gdnative.Variant)
	ForceDrag(data gdnative.Variant, preview ObjectImplementer)
	GetAnchor(margin gdnative.Int) gdnative.Real
	GetBegin() gdnative.Vector2
	GetColor(name gdnative.String, aType gdnative.String) gdnative.Color
	GetCombinedMinimumSize() gdnative.Vector2
	GetConstant(name gdnative.String, aType gdnative.String) gdnative.Int
	GetCustomMinimumSize() gdnative.Vector2
	GetDragData(position gdnative.Vector2) ObjectImplementer
	GetEnd() gdnative.Vector2
	GetFocusNeighbour(margin gdnative.Int) gdnative.NodePath
	GetFocusNext() gdnative.NodePath
	GetFocusOwner() ControlImplementer
	GetFocusPrevious() gdnative.NodePath
	GetFont(name gdnative.String, aType gdnative.String) FontImplementer
	GetGlobalPosition() gdnative.Vector2
	GetGlobalRect() gdnative.Rect2
	GetHSizeFlags() gdnative.Int
	GetIcon(name gdnative.String, aType gdnative.String) TextureImplementer
	GetMargin(margin gdnative.Int) gdnative.Real
	GetMinimumSize() gdnative.Vector2
	GetParentAreaSize() gdnative.Vector2
	GetParentControl() ControlImplementer
	GetPivotOffset() gdnative.Vector2
	GetPosition() gdnative.Vector2
	GetRect() gdnative.Rect2
	GetRotation() gdnative.Real
	GetRotationDegrees() gdnative.Real
	GetScale() gdnative.Vector2
	GetSize() gdnative.Vector2
	GetStretchRatio() gdnative.Real
	GetStylebox(name gdnative.String, aType gdnative.String) StyleBoxImplementer
	GetTheme() ThemeImplementer
	GetTooltip(atPosition gdnative.Vector2) gdnative.String
	GetVSizeFlags() gdnative.Int
	GrabClickFocus()
	GrabFocus()
	HasColor(name gdnative.String, aType gdnative.String) gdnative.Bool
	HasColorOverride(name gdnative.String) gdnative.Bool
	HasConstant(name gdnative.String, aType gdnative.String) gdnative.Bool
	HasConstantOverride(name gdnative.String) gdnative.Bool
	HasFocus() gdnative.Bool
	HasFont(name gdnative.String, aType gdnative.String) gdnative.Bool
	HasFontOverride(name gdnative.String) gdnative.Bool
	HasIcon(name gdnative.String, aType gdnative.String) gdnative.Bool
	HasIconOverride(name gdnative.String) gdnative.Bool
	HasPoint(point gdnative.Vector2) gdnative.Bool
	HasShaderOverride(name gdnative.String) gdnative.Bool
	HasStylebox(name gdnative.String, aType gdnative.String) gdnative.Bool
	HasStyleboxOverride(name gdnative.String) gdnative.Bool
	IsClippingContents() gdnative.Bool
	MinimumSizeChanged()
	ReleaseFocus()
	SetAnchor(margin gdnative.Int, anchor gdnative.Real, keepMargin gdnative.Bool, pushOppositeAnchor gdnative.Bool)
	SetAnchorAndMargin(margin gdnative.Int, anchor gdnative.Real, offset gdnative.Real, pushOppositeAnchor gdnative.Bool)
	SetAnchorsAndMarginsPreset(preset gdnative.Int, resizeMode gdnative.Int, margin gdnative.Int)
	SetAnchorsPreset(preset gdnative.Int, keepMargin gdnative.Bool)
	SetBegin(position gdnative.Vector2)
	SetClipContents(enable gdnative.Bool)
	SetCustomMinimumSize(size gdnative.Vector2)
	SetDefaultCursorShape(shape gdnative.Int)
	SetDragForwarding(target ObjectImplementer)
	SetDragPreview(control ObjectImplementer)
	SetEnd(position gdnative.Vector2)
	SetFocusMode(mode gdnative.Int)
	SetFocusNeighbour(margin gdnative.Int, neighbour gdnative.NodePath)
	SetFocusNext(next gdnative.NodePath)
	SetFocusPrevious(previous gdnative.NodePath)
	SetGlobalPosition(position gdnative.Vector2)
	SetHGrowDirection(direction gdnative.Int)
	SetHSizeFlags(flags gdnative.Int)
	SetMargin(margin gdnative.Int, offset gdnative.Real)
	SetMarginsPreset(preset gdnative.Int, resizeMode gdnative.Int, margin gdnative.Int)
	SetMouseFilter(filter gdnative.Int)
	SetPivotOffset(pivotOffset gdnative.Vector2)
	SetPosition(position gdnative.Vector2)
	SetRotation(radians gdnative.Real)
	SetRotationDegrees(degrees gdnative.Real)
	SetScale(scale gdnative.Vector2)
	SetSize(size gdnative.Vector2)
	SetStretchRatio(ratio gdnative.Real)
	SetTheme(theme ThemeImplementer)
	SetTooltip(tooltip gdnative.String)
	SetVGrowDirection(direction gdnative.Int)
	SetVSizeFlags(flags gdnative.Int)
	ShowModal(exclusive gdnative.Bool)
	WarpMouse(toPosition gdnative.Vector2)
}
