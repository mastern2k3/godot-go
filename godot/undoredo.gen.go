package godot

import (
	"github.com/shadowapex/godot-go/gdnative"
)

/*------------------------------------------------------------------------------
//   This code was generated by a tool.
//
//   Changes to this file may cause incorrect behavior and will be lost if
//   the code is regenerated. Any updates should be done in
//   "class.go.tmpl" so they can be included in the generated
//   code.
//----------------------------------------------------------------------------*/

// UndoRedoMergeMode is an enum for MergeMode values.
type UndoRedoMergeMode int

const (
	UndoRedoMergeAll     UndoRedoMergeMode = 2
	UndoRedoMergeDisable UndoRedoMergeMode = 0
	UndoRedoMergeEnds    UndoRedoMergeMode = 1
)

//func NewUndoRedoFromPointer(ptr gdnative.Pointer) UndoRedo {
func newUndoRedoFromPointer(ptr gdnative.Pointer) UndoRedo {
	owner := gdnative.NewObjectFromPointer(ptr)
	obj := UndoRedo{}
	obj.SetBaseObject(owner)

	return obj
}

/*
Helper to manage UndoRedo in the editor or custom tools. It works by registering methods and property changes inside 'actions'. Common behavior is to create an action, then add do/undo calls to functions or property changes, then committing the action. Here's an example on how to add an action to Godot editor's own 'undoredo': [codeblock] var undo_redo = get_undo_redo() # Method of EditorPlugin. func do_something(): pass # Put your code here. func undo_something(): pass # Put here the code that reverts what's done by "do_something()". func _on_MyButton_pressed(): var node = get_node("MyNode2D") undo_redo.create_action("Move the node") undo_redo.add_do_method(self, "do_something") undo_redo.add_undo_method(self, "undo_something") undo_redo.add_do_property(node, "position", Vector2(100,100)) undo_redo.add_undo_property(node, "position", node.position) undo_redo.commit_action() [/codeblock] [method create_action], [method add_do_method], [method add_undo_method], [method add_do_property], [method add_undo_property], and [method commit_action] should be called one after the other, like in the example. Not doing so could lead to crashes. If you don't need to register a method you can leave [method add_do_method] and [method add_undo_method] out, and so it goes for properties. You can register more than one method/property.
*/
type UndoRedo struct {
	Object
	owner gdnative.Object
}

func (o *UndoRedo) BaseClass() string {
	return "UndoRedo"
}

/*
        Register a method that will be called when the action is committed.
	Args: [{ false object Object} { false method String}], Returns: Variant
*/
func (o *UndoRedo) AddDoMethod(object ObjectImplementer, method gdnative.String) gdnative.Variant {
	//log.Println("Calling UndoRedo.AddDoMethod()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 2, 2)
	ptrArguments[0] = gdnative.NewPointerFromObject(object.GetBaseObject())
	ptrArguments[1] = gdnative.NewPointerFromString(method)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("UndoRedo", "add_do_method")

	// Call the parent method.
	// Variant
	retPtr := gdnative.NewEmptyVariant()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := gdnative.NewVariantFromPointer(retPtr)
	return ret
}

/*
        Register a property value change for 'do'.
	Args: [{ false object Object} { false property String} { false value Variant}], Returns: void
*/
func (o *UndoRedo) AddDoProperty(object ObjectImplementer, property gdnative.String, value gdnative.Variant) {
	//log.Println("Calling UndoRedo.AddDoProperty()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 3, 3)
	ptrArguments[0] = gdnative.NewPointerFromObject(object.GetBaseObject())
	ptrArguments[1] = gdnative.NewPointerFromString(property)
	ptrArguments[2] = gdnative.NewPointerFromVariant(value)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("UndoRedo", "add_do_property")

	// Call the parent method.
	// void
	retPtr := gdnative.NewEmptyVoid()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

}

/*
        Register a reference for 'do' that will be erased if the 'do' history is lost. This is useful mostly for new nodes created for the 'do' call. Do not use for resources.
	Args: [{ false object Object}], Returns: void
*/
func (o *UndoRedo) AddDoReference(object ObjectImplementer) {
	//log.Println("Calling UndoRedo.AddDoReference()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 1, 1)
	ptrArguments[0] = gdnative.NewPointerFromObject(object.GetBaseObject())

	// Get the method bind
	methodBind := gdnative.NewMethodBind("UndoRedo", "add_do_reference")

	// Call the parent method.
	// void
	retPtr := gdnative.NewEmptyVoid()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

}

/*
        Register a method that will be called when the action is undone.
	Args: [{ false object Object} { false method String}], Returns: Variant
*/
func (o *UndoRedo) AddUndoMethod(object ObjectImplementer, method gdnative.String) gdnative.Variant {
	//log.Println("Calling UndoRedo.AddUndoMethod()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 2, 2)
	ptrArguments[0] = gdnative.NewPointerFromObject(object.GetBaseObject())
	ptrArguments[1] = gdnative.NewPointerFromString(method)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("UndoRedo", "add_undo_method")

	// Call the parent method.
	// Variant
	retPtr := gdnative.NewEmptyVariant()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := gdnative.NewVariantFromPointer(retPtr)
	return ret
}

/*
        Register a property value change for 'undo'.
	Args: [{ false object Object} { false property String} { false value Variant}], Returns: void
*/
func (o *UndoRedo) AddUndoProperty(object ObjectImplementer, property gdnative.String, value gdnative.Variant) {
	//log.Println("Calling UndoRedo.AddUndoProperty()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 3, 3)
	ptrArguments[0] = gdnative.NewPointerFromObject(object.GetBaseObject())
	ptrArguments[1] = gdnative.NewPointerFromString(property)
	ptrArguments[2] = gdnative.NewPointerFromVariant(value)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("UndoRedo", "add_undo_property")

	// Call the parent method.
	// void
	retPtr := gdnative.NewEmptyVoid()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

}

/*
        Register a reference for 'undo' that will be erased if the 'undo' history is lost. This is useful mostly for nodes removed with the 'do' call (not the 'undo' call!).
	Args: [{ false object Object}], Returns: void
*/
func (o *UndoRedo) AddUndoReference(object ObjectImplementer) {
	//log.Println("Calling UndoRedo.AddUndoReference()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 1, 1)
	ptrArguments[0] = gdnative.NewPointerFromObject(object.GetBaseObject())

	// Get the method bind
	methodBind := gdnative.NewMethodBind("UndoRedo", "add_undo_reference")

	// Call the parent method.
	// void
	retPtr := gdnative.NewEmptyVoid()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

}

/*
        Clear the undo/redo history and associated references. Passing [code]false[/code] to [code]increase_version[/code] will prevent the version number to be increased from this.
	Args: [{True true increase_version bool}], Returns: void
*/
func (o *UndoRedo) ClearHistory(increaseVersion gdnative.Bool) {
	//log.Println("Calling UndoRedo.ClearHistory()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 1, 1)
	ptrArguments[0] = gdnative.NewPointerFromBool(increaseVersion)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("UndoRedo", "clear_history")

	// Call the parent method.
	// void
	retPtr := gdnative.NewEmptyVoid()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

}

/*
        Commit the action. All 'do' methods/properties are called/set when this function is called.
	Args: [], Returns: void
*/
func (o *UndoRedo) CommitAction() {
	//log.Println("Calling UndoRedo.CommitAction()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 0, 0)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("UndoRedo", "commit_action")

	// Call the parent method.
	// void
	retPtr := gdnative.NewEmptyVoid()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

}

/*
        Create a new action. After this is called, do all your calls to [method add_do_method], [method add_undo_method], [method add_do_property], and [method add_undo_property], then commit the action with [method commit_action]. The way actions are merged is dictated by the [code]merge_mode[/code] argument. See [enum MergeMode] for details.
	Args: [{ false name String} {0 true merge_mode int}], Returns: void
*/
func (o *UndoRedo) CreateAction(name gdnative.String, mergeMode gdnative.Int) {
	//log.Println("Calling UndoRedo.CreateAction()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 2, 2)
	ptrArguments[0] = gdnative.NewPointerFromString(name)
	ptrArguments[1] = gdnative.NewPointerFromInt(mergeMode)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("UndoRedo", "create_action")

	// Call the parent method.
	// void
	retPtr := gdnative.NewEmptyVoid()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

}

/*
        Get the name of the current action.
	Args: [], Returns: String
*/
func (o *UndoRedo) GetCurrentActionName() gdnative.String {
	//log.Println("Calling UndoRedo.GetCurrentActionName()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 0, 0)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("UndoRedo", "get_current_action_name")

	// Call the parent method.
	// String
	retPtr := gdnative.NewEmptyString()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := gdnative.NewStringFromPointer(retPtr)
	return ret
}

/*
        Get the version, each time a new action is committed, the version number of the UndoRedo is increased automatically. This is useful mostly to check if something changed from a saved version.
	Args: [], Returns: int
*/
func (o *UndoRedo) GetVersion() gdnative.Int {
	//log.Println("Calling UndoRedo.GetVersion()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 0, 0)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("UndoRedo", "get_version")

	// Call the parent method.
	// int
	retPtr := gdnative.NewEmptyInt()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := gdnative.NewIntFromPointer(retPtr)
	return ret
}

/*

	Args: [], Returns: bool
*/
func (o *UndoRedo) IsCommitingAction() gdnative.Bool {
	//log.Println("Calling UndoRedo.IsCommitingAction()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 0, 0)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("UndoRedo", "is_commiting_action")

	// Call the parent method.
	// bool
	retPtr := gdnative.NewEmptyBool()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := gdnative.NewBoolFromPointer(retPtr)
	return ret
}

/*
        Redo last action.
	Args: [], Returns: bool
*/
func (o *UndoRedo) Redo() gdnative.Bool {
	//log.Println("Calling UndoRedo.Redo()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 0, 0)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("UndoRedo", "redo")

	// Call the parent method.
	// bool
	retPtr := gdnative.NewEmptyBool()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := gdnative.NewBoolFromPointer(retPtr)
	return ret
}

/*
        Undo last action.
	Args: [], Returns: bool
*/
func (o *UndoRedo) Undo() gdnative.Bool {
	//log.Println("Calling UndoRedo.Undo()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 0, 0)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("UndoRedo", "undo")

	// Call the parent method.
	// bool
	retPtr := gdnative.NewEmptyBool()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := gdnative.NewBoolFromPointer(retPtr)
	return ret
}

// UndoRedoImplementer is an interface that implements the methods
// of the UndoRedo class.
type UndoRedoImplementer interface {
	ObjectImplementer
	AddDoMethod(object ObjectImplementer, method gdnative.String) gdnative.Variant
	AddDoProperty(object ObjectImplementer, property gdnative.String, value gdnative.Variant)
	AddDoReference(object ObjectImplementer)
	AddUndoMethod(object ObjectImplementer, method gdnative.String) gdnative.Variant
	AddUndoProperty(object ObjectImplementer, property gdnative.String, value gdnative.Variant)
	AddUndoReference(object ObjectImplementer)
	ClearHistory(increaseVersion gdnative.Bool)
	CommitAction()
	CreateAction(name gdnative.String, mergeMode gdnative.Int)
	GetCurrentActionName() gdnative.String
	GetVersion() gdnative.Int
	IsCommitingAction() gdnative.Bool
	Redo() gdnative.Bool
	Undo() gdnative.Bool
}
