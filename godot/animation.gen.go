package godot

import (
	"github.com/shadowapex/godot-go/gdnative"
)

/*------------------------------------------------------------------------------
//   This code was generated by a tool.
//
//   Changes to this file may cause incorrect behavior and will be lost if
//   the code is regenerated. Any updates should be done in
//   "class.go.tmpl" so they can be included in the generated
//   code.
//----------------------------------------------------------------------------*/

// AnimationInterpolationType is an enum for InterpolationType values.
type AnimationInterpolationType int

const (
	AnimationInterpolationCubic   AnimationInterpolationType = 2
	AnimationInterpolationLinear  AnimationInterpolationType = 1
	AnimationInterpolationNearest AnimationInterpolationType = 0
)

// AnimationTrackType is an enum for TrackType values.
type AnimationTrackType int

const (
	AnimationTypeAnimation AnimationTrackType = 5
	AnimationTypeAudio     AnimationTrackType = 4
	AnimationTypeBezier    AnimationTrackType = 3
	AnimationTypeMethod    AnimationTrackType = 2
	AnimationTypeTransform AnimationTrackType = 1
	AnimationTypeValue     AnimationTrackType = 0
)

// AnimationUpdateMode is an enum for UpdateMode values.
type AnimationUpdateMode int

const (
	AnimationUpdateCapture    AnimationUpdateMode = 3
	AnimationUpdateContinuous AnimationUpdateMode = 0
	AnimationUpdateDiscrete   AnimationUpdateMode = 1
	AnimationUpdateTrigger    AnimationUpdateMode = 2
)

//func NewAnimationFromPointer(ptr gdnative.Pointer) Animation {
func newAnimationFromPointer(ptr gdnative.Pointer) Animation {
	owner := gdnative.NewObjectFromPointer(ptr)
	obj := Animation{}
	obj.SetBaseObject(owner)

	return obj
}

/*
An Animation resource contains data used to animate everything in the engine. Animations are divided into tracks, and each track must be linked to a node. The state of that node can be changed through time, by adding timed keys (events) to the track. [codeblock] # This creates an animation that makes the node "Enemy" move to the right by # 100 pixels in 1 second. var animation = Animation.new() var track_index = animation.add_track(Animation.TYPE_VALUE) animation.track_set_path(track_index, "Enemy:position.x") animation.track_insert_key(track_index, 0.0, 0) animation.track_insert_key(track_index, 0.5, 100) [/codeblock] Animations are just data containers, and must be added to nodes such as an [AnimationPlayer] or [AnimationTreePlayer] to be played back.
*/
type Animation struct {
	Resource
	owner gdnative.Object
}

func (o *Animation) BaseClass() string {
	return "Animation"
}

/*
        Add a track to the Animation. The track type must be specified as any of the values in the TYPE_* enumeration.
	Args: [{ false type int} {-1 true at_position int}], Returns: int
*/
func (o *Animation) AddTrack(aType gdnative.Int, atPosition gdnative.Int) gdnative.Int {
	//log.Println("Calling Animation.AddTrack()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 2, 2)
	ptrArguments[0] = gdnative.NewPointerFromInt(aType)
	ptrArguments[1] = gdnative.NewPointerFromInt(atPosition)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Animation", "add_track")

	// Call the parent method.
	// int
	retPtr := gdnative.NewEmptyInt()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := gdnative.NewIntFromPointer(retPtr)
	return ret
}

/*

	Args: [{ false idx int} { false key_idx int}], Returns: String
*/
func (o *Animation) AnimationTrackGetKeyAnimation(idx gdnative.Int, keyIdx gdnative.Int) gdnative.String {
	//log.Println("Calling Animation.AnimationTrackGetKeyAnimation()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 2, 2)
	ptrArguments[0] = gdnative.NewPointerFromInt(idx)
	ptrArguments[1] = gdnative.NewPointerFromInt(keyIdx)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Animation", "animation_track_get_key_animation")

	// Call the parent method.
	// String
	retPtr := gdnative.NewEmptyString()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := gdnative.NewStringFromPointer(retPtr)
	return ret
}

/*

	Args: [{ false track int} { false time float} { false animation String}], Returns: int
*/
func (o *Animation) AnimationTrackInsertKey(track gdnative.Int, time gdnative.Real, animation gdnative.String) gdnative.Int {
	//log.Println("Calling Animation.AnimationTrackInsertKey()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 3, 3)
	ptrArguments[0] = gdnative.NewPointerFromInt(track)
	ptrArguments[1] = gdnative.NewPointerFromReal(time)
	ptrArguments[2] = gdnative.NewPointerFromString(animation)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Animation", "animation_track_insert_key")

	// Call the parent method.
	// int
	retPtr := gdnative.NewEmptyInt()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := gdnative.NewIntFromPointer(retPtr)
	return ret
}

/*

	Args: [{ false idx int} { false key_idx int} { false animation String}], Returns: void
*/
func (o *Animation) AnimationTrackSetKeyAnimation(idx gdnative.Int, keyIdx gdnative.Int, animation gdnative.String) {
	//log.Println("Calling Animation.AnimationTrackSetKeyAnimation()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 3, 3)
	ptrArguments[0] = gdnative.NewPointerFromInt(idx)
	ptrArguments[1] = gdnative.NewPointerFromInt(keyIdx)
	ptrArguments[2] = gdnative.NewPointerFromString(animation)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Animation", "animation_track_set_key_animation")

	// Call the parent method.
	// void
	retPtr := gdnative.NewEmptyVoid()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

}

/*

	Args: [{ false idx int} { false key_idx int}], Returns: float
*/
func (o *Animation) AudioTrackGetKeyEndOffset(idx gdnative.Int, keyIdx gdnative.Int) gdnative.Real {
	//log.Println("Calling Animation.AudioTrackGetKeyEndOffset()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 2, 2)
	ptrArguments[0] = gdnative.NewPointerFromInt(idx)
	ptrArguments[1] = gdnative.NewPointerFromInt(keyIdx)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Animation", "audio_track_get_key_end_offset")

	// Call the parent method.
	// float
	retPtr := gdnative.NewEmptyReal()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := gdnative.NewRealFromPointer(retPtr)
	return ret
}

/*

	Args: [{ false idx int} { false key_idx int}], Returns: float
*/
func (o *Animation) AudioTrackGetKeyStartOffset(idx gdnative.Int, keyIdx gdnative.Int) gdnative.Real {
	//log.Println("Calling Animation.AudioTrackGetKeyStartOffset()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 2, 2)
	ptrArguments[0] = gdnative.NewPointerFromInt(idx)
	ptrArguments[1] = gdnative.NewPointerFromInt(keyIdx)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Animation", "audio_track_get_key_start_offset")

	// Call the parent method.
	// float
	retPtr := gdnative.NewEmptyReal()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := gdnative.NewRealFromPointer(retPtr)
	return ret
}

/*

	Args: [{ false idx int} { false key_idx int}], Returns: Resource
*/
func (o *Animation) AudioTrackGetKeyStream(idx gdnative.Int, keyIdx gdnative.Int) ResourceImplementer {
	//log.Println("Calling Animation.AudioTrackGetKeyStream()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 2, 2)
	ptrArguments[0] = gdnative.NewPointerFromInt(idx)
	ptrArguments[1] = gdnative.NewPointerFromInt(keyIdx)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Animation", "audio_track_get_key_stream")

	// Call the parent method.
	// Resource
	retPtr := gdnative.NewEmptyObject()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := newResourceFromPointer(retPtr)

	// Check to see if we already have an instance of this object in our Go instance registry.
	if instance, ok := InstanceRegistry.Get(ret.GetBaseObject().ID()); ok {
		return instance.(ResourceImplementer)
	}

	// Check to see what kind of class this is and create it. This is generally used with
	// GetNode().
	className := ret.GetClass()
	if className != "Resource" {
		actualRet := getActualClass(className, ret.GetBaseObject())
		return actualRet.(ResourceImplementer)
	}

	return &ret
}

/*

	Args: [{ false track int} { false time float} { false stream Resource} {0 true start_offset float} {0 true end_offset float}], Returns: int
*/
func (o *Animation) AudioTrackInsertKey(track gdnative.Int, time gdnative.Real, stream ResourceImplementer, startOffset gdnative.Real, endOffset gdnative.Real) gdnative.Int {
	//log.Println("Calling Animation.AudioTrackInsertKey()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 5, 5)
	ptrArguments[0] = gdnative.NewPointerFromInt(track)
	ptrArguments[1] = gdnative.NewPointerFromReal(time)
	ptrArguments[2] = gdnative.NewPointerFromObject(stream.GetBaseObject())
	ptrArguments[3] = gdnative.NewPointerFromReal(startOffset)
	ptrArguments[4] = gdnative.NewPointerFromReal(endOffset)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Animation", "audio_track_insert_key")

	// Call the parent method.
	// int
	retPtr := gdnative.NewEmptyInt()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := gdnative.NewIntFromPointer(retPtr)
	return ret
}

/*

	Args: [{ false idx int} { false key_idx int} { false offset float}], Returns: void
*/
func (o *Animation) AudioTrackSetKeyEndOffset(idx gdnative.Int, keyIdx gdnative.Int, offset gdnative.Real) {
	//log.Println("Calling Animation.AudioTrackSetKeyEndOffset()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 3, 3)
	ptrArguments[0] = gdnative.NewPointerFromInt(idx)
	ptrArguments[1] = gdnative.NewPointerFromInt(keyIdx)
	ptrArguments[2] = gdnative.NewPointerFromReal(offset)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Animation", "audio_track_set_key_end_offset")

	// Call the parent method.
	// void
	retPtr := gdnative.NewEmptyVoid()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

}

/*

	Args: [{ false idx int} { false key_idx int} { false offset float}], Returns: void
*/
func (o *Animation) AudioTrackSetKeyStartOffset(idx gdnative.Int, keyIdx gdnative.Int, offset gdnative.Real) {
	//log.Println("Calling Animation.AudioTrackSetKeyStartOffset()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 3, 3)
	ptrArguments[0] = gdnative.NewPointerFromInt(idx)
	ptrArguments[1] = gdnative.NewPointerFromInt(keyIdx)
	ptrArguments[2] = gdnative.NewPointerFromReal(offset)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Animation", "audio_track_set_key_start_offset")

	// Call the parent method.
	// void
	retPtr := gdnative.NewEmptyVoid()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

}

/*

	Args: [{ false idx int} { false key_idx int} { false stream Resource}], Returns: void
*/
func (o *Animation) AudioTrackSetKeyStream(idx gdnative.Int, keyIdx gdnative.Int, stream ResourceImplementer) {
	//log.Println("Calling Animation.AudioTrackSetKeyStream()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 3, 3)
	ptrArguments[0] = gdnative.NewPointerFromInt(idx)
	ptrArguments[1] = gdnative.NewPointerFromInt(keyIdx)
	ptrArguments[2] = gdnative.NewPointerFromObject(stream.GetBaseObject())

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Animation", "audio_track_set_key_stream")

	// Call the parent method.
	// void
	retPtr := gdnative.NewEmptyVoid()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

}

/*

	Args: [{ false idx int} { false key_idx int}], Returns: Vector2
*/
func (o *Animation) BezierTrackGetKeyInHandle(idx gdnative.Int, keyIdx gdnative.Int) gdnative.Vector2 {
	//log.Println("Calling Animation.BezierTrackGetKeyInHandle()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 2, 2)
	ptrArguments[0] = gdnative.NewPointerFromInt(idx)
	ptrArguments[1] = gdnative.NewPointerFromInt(keyIdx)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Animation", "bezier_track_get_key_in_handle")

	// Call the parent method.
	// Vector2
	retPtr := gdnative.NewEmptyVector2()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := gdnative.NewVector2FromPointer(retPtr)
	return ret
}

/*

	Args: [{ false idx int} { false key_idx int}], Returns: Vector2
*/
func (o *Animation) BezierTrackGetKeyOutHandle(idx gdnative.Int, keyIdx gdnative.Int) gdnative.Vector2 {
	//log.Println("Calling Animation.BezierTrackGetKeyOutHandle()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 2, 2)
	ptrArguments[0] = gdnative.NewPointerFromInt(idx)
	ptrArguments[1] = gdnative.NewPointerFromInt(keyIdx)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Animation", "bezier_track_get_key_out_handle")

	// Call the parent method.
	// Vector2
	retPtr := gdnative.NewEmptyVector2()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := gdnative.NewVector2FromPointer(retPtr)
	return ret
}

/*

	Args: [{ false idx int} { false key_idx int}], Returns: float
*/
func (o *Animation) BezierTrackGetKeyValue(idx gdnative.Int, keyIdx gdnative.Int) gdnative.Real {
	//log.Println("Calling Animation.BezierTrackGetKeyValue()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 2, 2)
	ptrArguments[0] = gdnative.NewPointerFromInt(idx)
	ptrArguments[1] = gdnative.NewPointerFromInt(keyIdx)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Animation", "bezier_track_get_key_value")

	// Call the parent method.
	// float
	retPtr := gdnative.NewEmptyReal()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := gdnative.NewRealFromPointer(retPtr)
	return ret
}

/*

	Args: [{ false track int} { false time float} { false value float} {(0, 0) true in_handle Vector2} {(0, 0) true out_handle Vector2}], Returns: int
*/
func (o *Animation) BezierTrackInsertKey(track gdnative.Int, time gdnative.Real, value gdnative.Real, inHandle gdnative.Vector2, outHandle gdnative.Vector2) gdnative.Int {
	//log.Println("Calling Animation.BezierTrackInsertKey()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 5, 5)
	ptrArguments[0] = gdnative.NewPointerFromInt(track)
	ptrArguments[1] = gdnative.NewPointerFromReal(time)
	ptrArguments[2] = gdnative.NewPointerFromReal(value)
	ptrArguments[3] = gdnative.NewPointerFromVector2(inHandle)
	ptrArguments[4] = gdnative.NewPointerFromVector2(outHandle)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Animation", "bezier_track_insert_key")

	// Call the parent method.
	// int
	retPtr := gdnative.NewEmptyInt()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := gdnative.NewIntFromPointer(retPtr)
	return ret
}

/*

	Args: [{ false track int} { false time float}], Returns: float
*/
func (o *Animation) BezierTrackInterpolate(track gdnative.Int, time gdnative.Real) gdnative.Real {
	//log.Println("Calling Animation.BezierTrackInterpolate()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 2, 2)
	ptrArguments[0] = gdnative.NewPointerFromInt(track)
	ptrArguments[1] = gdnative.NewPointerFromReal(time)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Animation", "bezier_track_interpolate")

	// Call the parent method.
	// float
	retPtr := gdnative.NewEmptyReal()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := gdnative.NewRealFromPointer(retPtr)
	return ret
}

/*

	Args: [{ false idx int} { false key_idx int} { false in_handle Vector2}], Returns: void
*/
func (o *Animation) BezierTrackSetKeyInHandle(idx gdnative.Int, keyIdx gdnative.Int, inHandle gdnative.Vector2) {
	//log.Println("Calling Animation.BezierTrackSetKeyInHandle()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 3, 3)
	ptrArguments[0] = gdnative.NewPointerFromInt(idx)
	ptrArguments[1] = gdnative.NewPointerFromInt(keyIdx)
	ptrArguments[2] = gdnative.NewPointerFromVector2(inHandle)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Animation", "bezier_track_set_key_in_handle")

	// Call the parent method.
	// void
	retPtr := gdnative.NewEmptyVoid()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

}

/*

	Args: [{ false idx int} { false key_idx int} { false out_handle Vector2}], Returns: void
*/
func (o *Animation) BezierTrackSetKeyOutHandle(idx gdnative.Int, keyIdx gdnative.Int, outHandle gdnative.Vector2) {
	//log.Println("Calling Animation.BezierTrackSetKeyOutHandle()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 3, 3)
	ptrArguments[0] = gdnative.NewPointerFromInt(idx)
	ptrArguments[1] = gdnative.NewPointerFromInt(keyIdx)
	ptrArguments[2] = gdnative.NewPointerFromVector2(outHandle)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Animation", "bezier_track_set_key_out_handle")

	// Call the parent method.
	// void
	retPtr := gdnative.NewEmptyVoid()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

}

/*

	Args: [{ false idx int} { false key_idx int} { false value float}], Returns: void
*/
func (o *Animation) BezierTrackSetKeyValue(idx gdnative.Int, keyIdx gdnative.Int, value gdnative.Real) {
	//log.Println("Calling Animation.BezierTrackSetKeyValue()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 3, 3)
	ptrArguments[0] = gdnative.NewPointerFromInt(idx)
	ptrArguments[1] = gdnative.NewPointerFromInt(keyIdx)
	ptrArguments[2] = gdnative.NewPointerFromReal(value)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Animation", "bezier_track_set_key_value")

	// Call the parent method.
	// void
	retPtr := gdnative.NewEmptyVoid()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

}

/*
        Clear the animation (clear all tracks and reset all).
	Args: [], Returns: void
*/
func (o *Animation) Clear() {
	//log.Println("Calling Animation.Clear()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 0, 0)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Animation", "clear")

	// Call the parent method.
	// void
	retPtr := gdnative.NewEmptyVoid()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

}

/*
        Adds a new track that is a copy of the given track from [code]to_animation[/code].
	Args: [{ false track int} { false to_animation Animation}], Returns: void
*/
func (o *Animation) CopyTrack(track gdnative.Int, toAnimation AnimationImplementer) {
	//log.Println("Calling Animation.CopyTrack()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 2, 2)
	ptrArguments[0] = gdnative.NewPointerFromInt(track)
	ptrArguments[1] = gdnative.NewPointerFromObject(toAnimation.GetBaseObject())

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Animation", "copy_track")

	// Call the parent method.
	// void
	retPtr := gdnative.NewEmptyVoid()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

}

/*
        Return the index of the specified track. If the track is not found, return -1.
	Args: [{ false path NodePath}], Returns: int
*/
func (o *Animation) FindTrack(path gdnative.NodePath) gdnative.Int {
	//log.Println("Calling Animation.FindTrack()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 1, 1)
	ptrArguments[0] = gdnative.NewPointerFromNodePath(path)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Animation", "find_track")

	// Call the parent method.
	// int
	retPtr := gdnative.NewEmptyInt()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := gdnative.NewIntFromPointer(retPtr)
	return ret
}

/*
        Undocumented
	Args: [], Returns: float
*/
func (o *Animation) GetLength() gdnative.Real {
	//log.Println("Calling Animation.GetLength()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 0, 0)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Animation", "get_length")

	// Call the parent method.
	// float
	retPtr := gdnative.NewEmptyReal()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := gdnative.NewRealFromPointer(retPtr)
	return ret
}

/*
        Undocumented
	Args: [], Returns: float
*/
func (o *Animation) GetStep() gdnative.Real {
	//log.Println("Calling Animation.GetStep()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 0, 0)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Animation", "get_step")

	// Call the parent method.
	// float
	retPtr := gdnative.NewEmptyReal()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := gdnative.NewRealFromPointer(retPtr)
	return ret
}

/*
        Return the amount of tracks in the animation.
	Args: [], Returns: int
*/
func (o *Animation) GetTrackCount() gdnative.Int {
	//log.Println("Calling Animation.GetTrackCount()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 0, 0)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Animation", "get_track_count")

	// Call the parent method.
	// int
	retPtr := gdnative.NewEmptyInt()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := gdnative.NewIntFromPointer(retPtr)
	return ret
}

/*
        Undocumented
	Args: [], Returns: bool
*/
func (o *Animation) HasLoop() gdnative.Bool {
	//log.Println("Calling Animation.HasLoop()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 0, 0)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Animation", "has_loop")

	// Call the parent method.
	// bool
	retPtr := gdnative.NewEmptyBool()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := gdnative.NewBoolFromPointer(retPtr)
	return ret
}

/*
        Return all the key indices of a method track, given a position and delta time.
	Args: [{ false idx int} { false time_sec float} { false delta float}], Returns: PoolIntArray
*/
func (o *Animation) MethodTrackGetKeyIndices(idx gdnative.Int, timeSec gdnative.Real, delta gdnative.Real) gdnative.PoolIntArray {
	//log.Println("Calling Animation.MethodTrackGetKeyIndices()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 3, 3)
	ptrArguments[0] = gdnative.NewPointerFromInt(idx)
	ptrArguments[1] = gdnative.NewPointerFromReal(timeSec)
	ptrArguments[2] = gdnative.NewPointerFromReal(delta)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Animation", "method_track_get_key_indices")

	// Call the parent method.
	// PoolIntArray
	retPtr := gdnative.NewEmptyPoolIntArray()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := gdnative.NewPoolIntArrayFromPointer(retPtr)
	return ret
}

/*
        Return the method name of a method track.
	Args: [{ false idx int} { false key_idx int}], Returns: String
*/
func (o *Animation) MethodTrackGetName(idx gdnative.Int, keyIdx gdnative.Int) gdnative.String {
	//log.Println("Calling Animation.MethodTrackGetName()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 2, 2)
	ptrArguments[0] = gdnative.NewPointerFromInt(idx)
	ptrArguments[1] = gdnative.NewPointerFromInt(keyIdx)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Animation", "method_track_get_name")

	// Call the parent method.
	// String
	retPtr := gdnative.NewEmptyString()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := gdnative.NewStringFromPointer(retPtr)
	return ret
}

/*
        Return the arguments values to be called on a method track for a given key in a given track.
	Args: [{ false idx int} { false key_idx int}], Returns: Array
*/
func (o *Animation) MethodTrackGetParams(idx gdnative.Int, keyIdx gdnative.Int) gdnative.Array {
	//log.Println("Calling Animation.MethodTrackGetParams()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 2, 2)
	ptrArguments[0] = gdnative.NewPointerFromInt(idx)
	ptrArguments[1] = gdnative.NewPointerFromInt(keyIdx)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Animation", "method_track_get_params")

	// Call the parent method.
	// Array
	retPtr := gdnative.NewEmptyArray()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := gdnative.NewArrayFromPointer(retPtr)
	return ret
}

/*
        Remove a track by specifying the track index.
	Args: [{ false idx int}], Returns: void
*/
func (o *Animation) RemoveTrack(idx gdnative.Int) {
	//log.Println("Calling Animation.RemoveTrack()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 1, 1)
	ptrArguments[0] = gdnative.NewPointerFromInt(idx)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Animation", "remove_track")

	// Call the parent method.
	// void
	retPtr := gdnative.NewEmptyVoid()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

}

/*
        Undocumented
	Args: [{ false time_sec float}], Returns: void
*/
func (o *Animation) SetLength(timeSec gdnative.Real) {
	//log.Println("Calling Animation.SetLength()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 1, 1)
	ptrArguments[0] = gdnative.NewPointerFromReal(timeSec)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Animation", "set_length")

	// Call the parent method.
	// void
	retPtr := gdnative.NewEmptyVoid()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

}

/*
        Undocumented
	Args: [{ false enabled bool}], Returns: void
*/
func (o *Animation) SetLoop(enabled gdnative.Bool) {
	//log.Println("Calling Animation.SetLoop()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 1, 1)
	ptrArguments[0] = gdnative.NewPointerFromBool(enabled)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Animation", "set_loop")

	// Call the parent method.
	// void
	retPtr := gdnative.NewEmptyVoid()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

}

/*
        Undocumented
	Args: [{ false size_sec float}], Returns: void
*/
func (o *Animation) SetStep(sizeSec gdnative.Real) {
	//log.Println("Calling Animation.SetStep()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 1, 1)
	ptrArguments[0] = gdnative.NewPointerFromReal(sizeSec)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Animation", "set_step")

	// Call the parent method.
	// void
	retPtr := gdnative.NewEmptyVoid()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

}

/*
        Find the key index by time in a given track. Optionally, only find it if the exact time is given.
	Args: [{ false idx int} { false time float} {False true exact bool}], Returns: int
*/
func (o *Animation) TrackFindKey(idx gdnative.Int, time gdnative.Real, exact gdnative.Bool) gdnative.Int {
	//log.Println("Calling Animation.TrackFindKey()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 3, 3)
	ptrArguments[0] = gdnative.NewPointerFromInt(idx)
	ptrArguments[1] = gdnative.NewPointerFromReal(time)
	ptrArguments[2] = gdnative.NewPointerFromBool(exact)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Animation", "track_find_key")

	// Call the parent method.
	// int
	retPtr := gdnative.NewEmptyInt()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := gdnative.NewIntFromPointer(retPtr)
	return ret
}

/*
        Returns [code]true[/code] if the track at [code]idx[/code] wraps the interpolation loop. Default value: [code]true[/code].
	Args: [{ false idx int}], Returns: bool
*/
func (o *Animation) TrackGetInterpolationLoopWrap(idx gdnative.Int) gdnative.Bool {
	//log.Println("Calling Animation.TrackGetInterpolationLoopWrap()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 1, 1)
	ptrArguments[0] = gdnative.NewPointerFromInt(idx)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Animation", "track_get_interpolation_loop_wrap")

	// Call the parent method.
	// bool
	retPtr := gdnative.NewEmptyBool()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := gdnative.NewBoolFromPointer(retPtr)
	return ret
}

/*
        Return the interpolation type of a given track, from the INTERPOLATION_* enum.
	Args: [{ false idx int}], Returns: enum.Animation::InterpolationType
*/
func (o *Animation) TrackGetInterpolationType(idx gdnative.Int) AnimationInterpolationType {
	//log.Println("Calling Animation.TrackGetInterpolationType()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 1, 1)
	ptrArguments[0] = gdnative.NewPointerFromInt(idx)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Animation", "track_get_interpolation_type")

	// Call the parent method.
	// enum.Animation::InterpolationType
	retPtr := gdnative.NewEmptyInt()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := gdnative.NewIntFromPointer(retPtr)
	return AnimationInterpolationType(ret)
}

/*
        Return the amount of keys in a given track.
	Args: [{ false idx int}], Returns: int
*/
func (o *Animation) TrackGetKeyCount(idx gdnative.Int) gdnative.Int {
	//log.Println("Calling Animation.TrackGetKeyCount()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 1, 1)
	ptrArguments[0] = gdnative.NewPointerFromInt(idx)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Animation", "track_get_key_count")

	// Call the parent method.
	// int
	retPtr := gdnative.NewEmptyInt()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := gdnative.NewIntFromPointer(retPtr)
	return ret
}

/*
        Return the time at which the key is located.
	Args: [{ false idx int} { false key_idx int}], Returns: float
*/
func (o *Animation) TrackGetKeyTime(idx gdnative.Int, keyIdx gdnative.Int) gdnative.Real {
	//log.Println("Calling Animation.TrackGetKeyTime()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 2, 2)
	ptrArguments[0] = gdnative.NewPointerFromInt(idx)
	ptrArguments[1] = gdnative.NewPointerFromInt(keyIdx)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Animation", "track_get_key_time")

	// Call the parent method.
	// float
	retPtr := gdnative.NewEmptyReal()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := gdnative.NewRealFromPointer(retPtr)
	return ret
}

/*
        Return the transition curve (easing) for a specific key (see built-in math function "ease").
	Args: [{ false idx int} { false key_idx int}], Returns: float
*/
func (o *Animation) TrackGetKeyTransition(idx gdnative.Int, keyIdx gdnative.Int) gdnative.Real {
	//log.Println("Calling Animation.TrackGetKeyTransition()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 2, 2)
	ptrArguments[0] = gdnative.NewPointerFromInt(idx)
	ptrArguments[1] = gdnative.NewPointerFromInt(keyIdx)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Animation", "track_get_key_transition")

	// Call the parent method.
	// float
	retPtr := gdnative.NewEmptyReal()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := gdnative.NewRealFromPointer(retPtr)
	return ret
}

/*
        Return the value of a given key in a given track.
	Args: [{ false idx int} { false key_idx int}], Returns: Variant
*/
func (o *Animation) TrackGetKeyValue(idx gdnative.Int, keyIdx gdnative.Int) gdnative.Variant {
	//log.Println("Calling Animation.TrackGetKeyValue()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 2, 2)
	ptrArguments[0] = gdnative.NewPointerFromInt(idx)
	ptrArguments[1] = gdnative.NewPointerFromInt(keyIdx)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Animation", "track_get_key_value")

	// Call the parent method.
	// Variant
	retPtr := gdnative.NewEmptyVariant()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := gdnative.NewVariantFromPointer(retPtr)
	return ret
}

/*
        Get the path of a track. for more information on the path format, see [method track_set_path]
	Args: [{ false idx int}], Returns: NodePath
*/
func (o *Animation) TrackGetPath(idx gdnative.Int) gdnative.NodePath {
	//log.Println("Calling Animation.TrackGetPath()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 1, 1)
	ptrArguments[0] = gdnative.NewPointerFromInt(idx)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Animation", "track_get_path")

	// Call the parent method.
	// NodePath
	retPtr := gdnative.NewEmptyNodePath()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := gdnative.NewNodePathFromPointer(retPtr)
	return ret
}

/*
        Get the type of a track.
	Args: [{ false idx int}], Returns: enum.Animation::TrackType
*/
func (o *Animation) TrackGetType(idx gdnative.Int) AnimationTrackType {
	//log.Println("Calling Animation.TrackGetType()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 1, 1)
	ptrArguments[0] = gdnative.NewPointerFromInt(idx)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Animation", "track_get_type")

	// Call the parent method.
	// enum.Animation::TrackType
	retPtr := gdnative.NewEmptyInt()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := gdnative.NewIntFromPointer(retPtr)
	return AnimationTrackType(ret)
}

/*
        Insert a generic key in a given track.
	Args: [{ false idx int} { false time float} { false key Variant} {1 true transition float}], Returns: void
*/
func (o *Animation) TrackInsertKey(idx gdnative.Int, time gdnative.Real, key gdnative.Variant, transition gdnative.Real) {
	//log.Println("Calling Animation.TrackInsertKey()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 4, 4)
	ptrArguments[0] = gdnative.NewPointerFromInt(idx)
	ptrArguments[1] = gdnative.NewPointerFromReal(time)
	ptrArguments[2] = gdnative.NewPointerFromVariant(key)
	ptrArguments[3] = gdnative.NewPointerFromReal(transition)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Animation", "track_insert_key")

	// Call the parent method.
	// void
	retPtr := gdnative.NewEmptyVoid()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

}

/*
        Returns [code]true[/code] if the track at index [code]idx[/code] is enabled.
	Args: [{ false idx int}], Returns: bool
*/
func (o *Animation) TrackIsEnabled(idx gdnative.Int) gdnative.Bool {
	//log.Println("Calling Animation.TrackIsEnabled()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 1, 1)
	ptrArguments[0] = gdnative.NewPointerFromInt(idx)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Animation", "track_is_enabled")

	// Call the parent method.
	// bool
	retPtr := gdnative.NewEmptyBool()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := gdnative.NewBoolFromPointer(retPtr)
	return ret
}

/*
        Return true if the given track is imported. Else, return false.
	Args: [{ false idx int}], Returns: bool
*/
func (o *Animation) TrackIsImported(idx gdnative.Int) gdnative.Bool {
	//log.Println("Calling Animation.TrackIsImported()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 1, 1)
	ptrArguments[0] = gdnative.NewPointerFromInt(idx)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Animation", "track_is_imported")

	// Call the parent method.
	// bool
	retPtr := gdnative.NewEmptyBool()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := gdnative.NewBoolFromPointer(retPtr)
	return ret
}

/*
        Move a track down.
	Args: [{ false idx int}], Returns: void
*/
func (o *Animation) TrackMoveDown(idx gdnative.Int) {
	//log.Println("Calling Animation.TrackMoveDown()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 1, 1)
	ptrArguments[0] = gdnative.NewPointerFromInt(idx)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Animation", "track_move_down")

	// Call the parent method.
	// void
	retPtr := gdnative.NewEmptyVoid()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

}

/*
        Move a track up.
	Args: [{ false idx int}], Returns: void
*/
func (o *Animation) TrackMoveUp(idx gdnative.Int) {
	//log.Println("Calling Animation.TrackMoveUp()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 1, 1)
	ptrArguments[0] = gdnative.NewPointerFromInt(idx)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Animation", "track_move_up")

	// Call the parent method.
	// void
	retPtr := gdnative.NewEmptyVoid()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

}

/*
        Remove a key by index in a given track.
	Args: [{ false idx int} { false key_idx int}], Returns: void
*/
func (o *Animation) TrackRemoveKey(idx gdnative.Int, keyIdx gdnative.Int) {
	//log.Println("Calling Animation.TrackRemoveKey()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 2, 2)
	ptrArguments[0] = gdnative.NewPointerFromInt(idx)
	ptrArguments[1] = gdnative.NewPointerFromInt(keyIdx)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Animation", "track_remove_key")

	// Call the parent method.
	// void
	retPtr := gdnative.NewEmptyVoid()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

}

/*
        Remove a key by position (seconds) in a given track.
	Args: [{ false idx int} { false position float}], Returns: void
*/
func (o *Animation) TrackRemoveKeyAtPosition(idx gdnative.Int, position gdnative.Real) {
	//log.Println("Calling Animation.TrackRemoveKeyAtPosition()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 2, 2)
	ptrArguments[0] = gdnative.NewPointerFromInt(idx)
	ptrArguments[1] = gdnative.NewPointerFromReal(position)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Animation", "track_remove_key_at_position")

	// Call the parent method.
	// void
	retPtr := gdnative.NewEmptyVoid()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

}

/*
        Enables/disables the given track. Tracks are enabled by default.
	Args: [{ false idx int} { false enabled bool}], Returns: void
*/
func (o *Animation) TrackSetEnabled(idx gdnative.Int, enabled gdnative.Bool) {
	//log.Println("Calling Animation.TrackSetEnabled()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 2, 2)
	ptrArguments[0] = gdnative.NewPointerFromInt(idx)
	ptrArguments[1] = gdnative.NewPointerFromBool(enabled)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Animation", "track_set_enabled")

	// Call the parent method.
	// void
	retPtr := gdnative.NewEmptyVoid()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

}

/*
        Set the given track as imported or not.
	Args: [{ false idx int} { false imported bool}], Returns: void
*/
func (o *Animation) TrackSetImported(idx gdnative.Int, imported gdnative.Bool) {
	//log.Println("Calling Animation.TrackSetImported()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 2, 2)
	ptrArguments[0] = gdnative.NewPointerFromInt(idx)
	ptrArguments[1] = gdnative.NewPointerFromBool(imported)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Animation", "track_set_imported")

	// Call the parent method.
	// void
	retPtr := gdnative.NewEmptyVoid()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

}

/*
        If [code]true[/code], the track at [code]idx[/code] wraps the interpolation loop.
	Args: [{ false idx int} { false interpolation bool}], Returns: void
*/
func (o *Animation) TrackSetInterpolationLoopWrap(idx gdnative.Int, interpolation gdnative.Bool) {
	//log.Println("Calling Animation.TrackSetInterpolationLoopWrap()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 2, 2)
	ptrArguments[0] = gdnative.NewPointerFromInt(idx)
	ptrArguments[1] = gdnative.NewPointerFromBool(interpolation)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Animation", "track_set_interpolation_loop_wrap")

	// Call the parent method.
	// void
	retPtr := gdnative.NewEmptyVoid()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

}

/*
        Set the interpolation type of a given track, from the INTERPOLATION_* enum.
	Args: [{ false idx int} { false interpolation int}], Returns: void
*/
func (o *Animation) TrackSetInterpolationType(idx gdnative.Int, interpolation gdnative.Int) {
	//log.Println("Calling Animation.TrackSetInterpolationType()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 2, 2)
	ptrArguments[0] = gdnative.NewPointerFromInt(idx)
	ptrArguments[1] = gdnative.NewPointerFromInt(interpolation)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Animation", "track_set_interpolation_type")

	// Call the parent method.
	// void
	retPtr := gdnative.NewEmptyVoid()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

}

/*
        Set the transition curve (easing) for a specific key (see built-in math function "ease").
	Args: [{ false idx int} { false key_idx int} { false transition float}], Returns: void
*/
func (o *Animation) TrackSetKeyTransition(idx gdnative.Int, keyIdx gdnative.Int, transition gdnative.Real) {
	//log.Println("Calling Animation.TrackSetKeyTransition()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 3, 3)
	ptrArguments[0] = gdnative.NewPointerFromInt(idx)
	ptrArguments[1] = gdnative.NewPointerFromInt(keyIdx)
	ptrArguments[2] = gdnative.NewPointerFromReal(transition)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Animation", "track_set_key_transition")

	// Call the parent method.
	// void
	retPtr := gdnative.NewEmptyVoid()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

}

/*
        Set the value of an existing key.
	Args: [{ false idx int} { false key int} { false value Variant}], Returns: void
*/
func (o *Animation) TrackSetKeyValue(idx gdnative.Int, key gdnative.Int, value gdnative.Variant) {
	//log.Println("Calling Animation.TrackSetKeyValue()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 3, 3)
	ptrArguments[0] = gdnative.NewPointerFromInt(idx)
	ptrArguments[1] = gdnative.NewPointerFromInt(key)
	ptrArguments[2] = gdnative.NewPointerFromVariant(value)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Animation", "track_set_key_value")

	// Call the parent method.
	// void
	retPtr := gdnative.NewEmptyVoid()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

}

/*
        Set the path of a track. Paths must be valid scene-tree paths to a node, and must be specified starting from the parent node of the node that will reproduce the animation. Tracks that control properties or bones must append their name after the path, separated by ":". [b]Example:[/b] "character/skeleton:ankle" or "character/mesh:transform/local".
	Args: [{ false idx int} { false path NodePath}], Returns: void
*/
func (o *Animation) TrackSetPath(idx gdnative.Int, path gdnative.NodePath) {
	//log.Println("Calling Animation.TrackSetPath()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 2, 2)
	ptrArguments[0] = gdnative.NewPointerFromInt(idx)
	ptrArguments[1] = gdnative.NewPointerFromNodePath(path)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Animation", "track_set_path")

	// Call the parent method.
	// void
	retPtr := gdnative.NewEmptyVoid()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

}

/*

	Args: [{ false idx int} { false with_idx int}], Returns: void
*/
func (o *Animation) TrackSwap(idx gdnative.Int, withIdx gdnative.Int) {
	//log.Println("Calling Animation.TrackSwap()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 2, 2)
	ptrArguments[0] = gdnative.NewPointerFromInt(idx)
	ptrArguments[1] = gdnative.NewPointerFromInt(withIdx)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Animation", "track_swap")

	// Call the parent method.
	// void
	retPtr := gdnative.NewEmptyVoid()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

}

/*
        Insert a transform key for a transform track.
	Args: [{ false idx int} { false time float} { false location Vector3} { false rotation Quat} { false scale Vector3}], Returns: int
*/
func (o *Animation) TransformTrackInsertKey(idx gdnative.Int, time gdnative.Real, location gdnative.Vector3, rotation gdnative.Quat, scale gdnative.Vector3) gdnative.Int {
	//log.Println("Calling Animation.TransformTrackInsertKey()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 5, 5)
	ptrArguments[0] = gdnative.NewPointerFromInt(idx)
	ptrArguments[1] = gdnative.NewPointerFromReal(time)
	ptrArguments[2] = gdnative.NewPointerFromVector3(location)
	ptrArguments[3] = gdnative.NewPointerFromQuat(rotation)
	ptrArguments[4] = gdnative.NewPointerFromVector3(scale)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Animation", "transform_track_insert_key")

	// Call the parent method.
	// int
	retPtr := gdnative.NewEmptyInt()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := gdnative.NewIntFromPointer(retPtr)
	return ret
}

/*
        Return the interpolated value of a transform track at a given time (in seconds). An array consisting of 3 elements: position ([Vector3]), rotation ([Quat]) and scale ([Vector3]).
	Args: [{ false idx int} { false time_sec float}], Returns: Array
*/
func (o *Animation) TransformTrackInterpolate(idx gdnative.Int, timeSec gdnative.Real) gdnative.Array {
	//log.Println("Calling Animation.TransformTrackInterpolate()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 2, 2)
	ptrArguments[0] = gdnative.NewPointerFromInt(idx)
	ptrArguments[1] = gdnative.NewPointerFromReal(timeSec)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Animation", "transform_track_interpolate")

	// Call the parent method.
	// Array
	retPtr := gdnative.NewEmptyArray()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := gdnative.NewArrayFromPointer(retPtr)
	return ret
}

/*
        Return all the key indices of a value track, given a position and delta time.
	Args: [{ false idx int} { false time_sec float} { false delta float}], Returns: PoolIntArray
*/
func (o *Animation) ValueTrackGetKeyIndices(idx gdnative.Int, timeSec gdnative.Real, delta gdnative.Real) gdnative.PoolIntArray {
	//log.Println("Calling Animation.ValueTrackGetKeyIndices()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 3, 3)
	ptrArguments[0] = gdnative.NewPointerFromInt(idx)
	ptrArguments[1] = gdnative.NewPointerFromReal(timeSec)
	ptrArguments[2] = gdnative.NewPointerFromReal(delta)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Animation", "value_track_get_key_indices")

	// Call the parent method.
	// PoolIntArray
	retPtr := gdnative.NewEmptyPoolIntArray()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := gdnative.NewPoolIntArrayFromPointer(retPtr)
	return ret
}

/*
        Return the update mode of a value track.
	Args: [{ false idx int}], Returns: enum.Animation::UpdateMode
*/
func (o *Animation) ValueTrackGetUpdateMode(idx gdnative.Int) AnimationUpdateMode {
	//log.Println("Calling Animation.ValueTrackGetUpdateMode()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 1, 1)
	ptrArguments[0] = gdnative.NewPointerFromInt(idx)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Animation", "value_track_get_update_mode")

	// Call the parent method.
	// enum.Animation::UpdateMode
	retPtr := gdnative.NewEmptyInt()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := gdnative.NewIntFromPointer(retPtr)
	return AnimationUpdateMode(ret)
}

/*
        Set the update mode (UPDATE_*) of a value track.
	Args: [{ false idx int} { false mode int}], Returns: void
*/
func (o *Animation) ValueTrackSetUpdateMode(idx gdnative.Int, mode gdnative.Int) {
	//log.Println("Calling Animation.ValueTrackSetUpdateMode()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 2, 2)
	ptrArguments[0] = gdnative.NewPointerFromInt(idx)
	ptrArguments[1] = gdnative.NewPointerFromInt(mode)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Animation", "value_track_set_update_mode")

	// Call the parent method.
	// void
	retPtr := gdnative.NewEmptyVoid()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

}

// AnimationImplementer is an interface that implements the methods
// of the Animation class.
type AnimationImplementer interface {
	ResourceImplementer
	AddTrack(aType gdnative.Int, atPosition gdnative.Int) gdnative.Int
	AnimationTrackGetKeyAnimation(idx gdnative.Int, keyIdx gdnative.Int) gdnative.String
	AnimationTrackInsertKey(track gdnative.Int, time gdnative.Real, animation gdnative.String) gdnative.Int
	AnimationTrackSetKeyAnimation(idx gdnative.Int, keyIdx gdnative.Int, animation gdnative.String)
	AudioTrackGetKeyEndOffset(idx gdnative.Int, keyIdx gdnative.Int) gdnative.Real
	AudioTrackGetKeyStartOffset(idx gdnative.Int, keyIdx gdnative.Int) gdnative.Real
	AudioTrackGetKeyStream(idx gdnative.Int, keyIdx gdnative.Int) ResourceImplementer
	AudioTrackInsertKey(track gdnative.Int, time gdnative.Real, stream ResourceImplementer, startOffset gdnative.Real, endOffset gdnative.Real) gdnative.Int
	AudioTrackSetKeyEndOffset(idx gdnative.Int, keyIdx gdnative.Int, offset gdnative.Real)
	AudioTrackSetKeyStartOffset(idx gdnative.Int, keyIdx gdnative.Int, offset gdnative.Real)
	AudioTrackSetKeyStream(idx gdnative.Int, keyIdx gdnative.Int, stream ResourceImplementer)
	BezierTrackGetKeyInHandle(idx gdnative.Int, keyIdx gdnative.Int) gdnative.Vector2
	BezierTrackGetKeyOutHandle(idx gdnative.Int, keyIdx gdnative.Int) gdnative.Vector2
	BezierTrackGetKeyValue(idx gdnative.Int, keyIdx gdnative.Int) gdnative.Real
	BezierTrackInsertKey(track gdnative.Int, time gdnative.Real, value gdnative.Real, inHandle gdnative.Vector2, outHandle gdnative.Vector2) gdnative.Int
	BezierTrackInterpolate(track gdnative.Int, time gdnative.Real) gdnative.Real
	BezierTrackSetKeyInHandle(idx gdnative.Int, keyIdx gdnative.Int, inHandle gdnative.Vector2)
	BezierTrackSetKeyOutHandle(idx gdnative.Int, keyIdx gdnative.Int, outHandle gdnative.Vector2)
	BezierTrackSetKeyValue(idx gdnative.Int, keyIdx gdnative.Int, value gdnative.Real)
	Clear()
	CopyTrack(track gdnative.Int, toAnimation AnimationImplementer)
	FindTrack(path gdnative.NodePath) gdnative.Int
	GetLength() gdnative.Real
	GetStep() gdnative.Real
	GetTrackCount() gdnative.Int
	HasLoop() gdnative.Bool
	MethodTrackGetKeyIndices(idx gdnative.Int, timeSec gdnative.Real, delta gdnative.Real) gdnative.PoolIntArray
	MethodTrackGetName(idx gdnative.Int, keyIdx gdnative.Int) gdnative.String
	MethodTrackGetParams(idx gdnative.Int, keyIdx gdnative.Int) gdnative.Array
	RemoveTrack(idx gdnative.Int)
	SetLength(timeSec gdnative.Real)
	SetLoop(enabled gdnative.Bool)
	SetStep(sizeSec gdnative.Real)
	TrackFindKey(idx gdnative.Int, time gdnative.Real, exact gdnative.Bool) gdnative.Int
	TrackGetInterpolationLoopWrap(idx gdnative.Int) gdnative.Bool
	TrackGetKeyCount(idx gdnative.Int) gdnative.Int
	TrackGetKeyTime(idx gdnative.Int, keyIdx gdnative.Int) gdnative.Real
	TrackGetKeyTransition(idx gdnative.Int, keyIdx gdnative.Int) gdnative.Real
	TrackGetKeyValue(idx gdnative.Int, keyIdx gdnative.Int) gdnative.Variant
	TrackGetPath(idx gdnative.Int) gdnative.NodePath
	TrackInsertKey(idx gdnative.Int, time gdnative.Real, key gdnative.Variant, transition gdnative.Real)
	TrackIsEnabled(idx gdnative.Int) gdnative.Bool
	TrackIsImported(idx gdnative.Int) gdnative.Bool
	TrackMoveDown(idx gdnative.Int)
	TrackMoveUp(idx gdnative.Int)
	TrackRemoveKey(idx gdnative.Int, keyIdx gdnative.Int)
	TrackRemoveKeyAtPosition(idx gdnative.Int, position gdnative.Real)
	TrackSetEnabled(idx gdnative.Int, enabled gdnative.Bool)
	TrackSetImported(idx gdnative.Int, imported gdnative.Bool)
	TrackSetInterpolationLoopWrap(idx gdnative.Int, interpolation gdnative.Bool)
	TrackSetInterpolationType(idx gdnative.Int, interpolation gdnative.Int)
	TrackSetKeyTransition(idx gdnative.Int, keyIdx gdnative.Int, transition gdnative.Real)
	TrackSetKeyValue(idx gdnative.Int, key gdnative.Int, value gdnative.Variant)
	TrackSetPath(idx gdnative.Int, path gdnative.NodePath)
	TrackSwap(idx gdnative.Int, withIdx gdnative.Int)
	TransformTrackInsertKey(idx gdnative.Int, time gdnative.Real, location gdnative.Vector3, rotation gdnative.Quat, scale gdnative.Vector3) gdnative.Int
	TransformTrackInterpolate(idx gdnative.Int, timeSec gdnative.Real) gdnative.Array
	ValueTrackGetKeyIndices(idx gdnative.Int, timeSec gdnative.Real, delta gdnative.Real) gdnative.PoolIntArray
	ValueTrackSetUpdateMode(idx gdnative.Int, mode gdnative.Int)
}
