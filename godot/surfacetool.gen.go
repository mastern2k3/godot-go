package godot

import (
	"github.com/shadowapex/godot-go/gdnative"
)

/*------------------------------------------------------------------------------
//   This code was generated by a tool.
//
//   Changes to this file may cause incorrect behavior and will be lost if
//   the code is regenerated. Any updates should be done in
//   "class.go.tmpl" so they can be included in the generated
//   code.
//----------------------------------------------------------------------------*/

//func NewSurfaceToolFromPointer(ptr gdnative.Pointer) SurfaceTool {
func newSurfaceToolFromPointer(ptr gdnative.Pointer) SurfaceTool {
	owner := gdnative.NewObjectFromPointer(ptr)
	obj := SurfaceTool{}
	obj.SetBaseObject(owner)

	return obj
}

/*
The [code]SurfaceTool[/code] is used to construct a [Mesh] by specifying vertex attributes individually. It can be used to construct a [Mesh] from script. All properties except index need to be added before a call to [method add_vertex]. For example adding vertex colors and UVs looks like [codeblock] var st = SurfaceTool.new() st.begin(Mesh.PRIMITIVE_TRIANGLES) st.add_color(Color(1, 0, 0)) st.add_uv(Vector2(0, 0)) st.add_vertex(Vector3(0, 0, 0)) [/codeblock] The [code]SurfaceTool[/code] now contains one vertex of a triangle which has a UV coordinate and a specified [Color]. If another vertex were added without calls to [method add_uv] or [method add_color] then the last values would be used. It is very important that vertex attributes are passed [b]before[/b] the call to [method add_vertex], failure to do this will result in an error when committing the vertex information to a mesh. Additionally, the attributes used before the first vertex is added determine the format of the mesh. For example if you only add UVs to the first vertex, you cannot add color to any of the subsequent vertices.
*/
type SurfaceTool struct {
	Reference
	owner gdnative.Object
}

func (o *SurfaceTool) BaseClass() string {
	return "SurfaceTool"
}

/*
        Add an array of bones for the next Vertex to use. Array must contain 4 integers.
	Args: [{ false bones PoolIntArray}], Returns: void
*/
func (o *SurfaceTool) AddBones(bones gdnative.PoolIntArray) {
	//log.Println("Calling SurfaceTool.AddBones()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 1, 1)
	ptrArguments[0] = gdnative.NewPointerFromPoolIntArray(bones)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("SurfaceTool", "add_bones")

	// Call the parent method.
	// void
	retPtr := gdnative.NewEmptyVoid()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

}

/*
        Specify a [Color] for the next Vertex to use.
	Args: [{ false color Color}], Returns: void
*/
func (o *SurfaceTool) AddColor(color gdnative.Color) {
	//log.Println("Calling SurfaceTool.AddColor()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 1, 1)
	ptrArguments[0] = gdnative.NewPointerFromColor(color)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("SurfaceTool", "add_color")

	// Call the parent method.
	// void
	retPtr := gdnative.NewEmptyVoid()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

}

/*
        Adds an index to index array if you are using indexed Vertices. Does not need to be called before adding Vertex.
	Args: [{ false index int}], Returns: void
*/
func (o *SurfaceTool) AddIndex(index gdnative.Int) {
	//log.Println("Calling SurfaceTool.AddIndex()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 1, 1)
	ptrArguments[0] = gdnative.NewPointerFromInt(index)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("SurfaceTool", "add_index")

	// Call the parent method.
	// void
	retPtr := gdnative.NewEmptyVoid()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

}

/*
        Specify a normal for the next Vertex to use.
	Args: [{ false normal Vector3}], Returns: void
*/
func (o *SurfaceTool) AddNormal(normal gdnative.Vector3) {
	//log.Println("Calling SurfaceTool.AddNormal()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 1, 1)
	ptrArguments[0] = gdnative.NewPointerFromVector3(normal)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("SurfaceTool", "add_normal")

	// Call the parent method.
	// void
	retPtr := gdnative.NewEmptyVoid()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

}

/*
        Specify whether current Vertex (if using only Vertex arrays) or current index (if also using index arrays) should utilize smooth normals for normal calculation.
	Args: [{ false smooth bool}], Returns: void
*/
func (o *SurfaceTool) AddSmoothGroup(smooth gdnative.Bool) {
	//log.Println("Calling SurfaceTool.AddSmoothGroup()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 1, 1)
	ptrArguments[0] = gdnative.NewPointerFromBool(smooth)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("SurfaceTool", "add_smooth_group")

	// Call the parent method.
	// void
	retPtr := gdnative.NewEmptyVoid()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

}

/*
        Specify a Tangent for the next Vertex to use.
	Args: [{ false tangent Plane}], Returns: void
*/
func (o *SurfaceTool) AddTangent(tangent gdnative.Plane) {
	//log.Println("Calling SurfaceTool.AddTangent()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 1, 1)
	ptrArguments[0] = gdnative.NewPointerFromPlane(tangent)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("SurfaceTool", "add_tangent")

	// Call the parent method.
	// void
	retPtr := gdnative.NewEmptyVoid()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

}

/*
        Insert a triangle fan made of array data into [Mesh] being constructed. Requires primitive type be set to [code]PRIMITIVE_TRIANGLES[/code].
	Args: [{ false vertices PoolVector3Array} {[] true uvs PoolVector2Array} {[PoolColorArray] true colors PoolColorArray} {[] true uv2s PoolVector2Array} {[] true normals PoolVector3Array} {[] true tangents Array}], Returns: void
*/
func (o *SurfaceTool) AddTriangleFan(vertices gdnative.PoolVector3Array, uvs gdnative.PoolVector2Array, colors gdnative.PoolColorArray, uv2S gdnative.PoolVector2Array, normals gdnative.PoolVector3Array, tangents gdnative.Array) {
	//log.Println("Calling SurfaceTool.AddTriangleFan()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 6, 6)
	ptrArguments[0] = gdnative.NewPointerFromPoolVector3Array(vertices)
	ptrArguments[1] = gdnative.NewPointerFromPoolVector2Array(uvs)
	ptrArguments[2] = gdnative.NewPointerFromPoolColorArray(colors)
	ptrArguments[3] = gdnative.NewPointerFromPoolVector2Array(uv2S)
	ptrArguments[4] = gdnative.NewPointerFromPoolVector3Array(normals)
	ptrArguments[5] = gdnative.NewPointerFromArray(tangents)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("SurfaceTool", "add_triangle_fan")

	// Call the parent method.
	// void
	retPtr := gdnative.NewEmptyVoid()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

}

/*
        Specify UV Coordinate for next Vertex to use.
	Args: [{ false uv Vector2}], Returns: void
*/
func (o *SurfaceTool) AddUv(uv gdnative.Vector2) {
	//log.Println("Calling SurfaceTool.AddUv()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 1, 1)
	ptrArguments[0] = gdnative.NewPointerFromVector2(uv)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("SurfaceTool", "add_uv")

	// Call the parent method.
	// void
	retPtr := gdnative.NewEmptyVoid()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

}

/*
        Specify an optional second set of UV coordinates for next Vertex to use.
	Args: [{ false uv2 Vector2}], Returns: void
*/
func (o *SurfaceTool) AddUv2(uv2 gdnative.Vector2) {
	//log.Println("Calling SurfaceTool.AddUv2()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 1, 1)
	ptrArguments[0] = gdnative.NewPointerFromVector2(uv2)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("SurfaceTool", "add_uv2")

	// Call the parent method.
	// void
	retPtr := gdnative.NewEmptyVoid()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

}

/*
        Specify position of current Vertex. Should be called after specifying other vertex properties (e.g. Color, UV).
	Args: [{ false vertex Vector3}], Returns: void
*/
func (o *SurfaceTool) AddVertex(vertex gdnative.Vector3) {
	//log.Println("Calling SurfaceTool.AddVertex()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 1, 1)
	ptrArguments[0] = gdnative.NewPointerFromVector3(vertex)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("SurfaceTool", "add_vertex")

	// Call the parent method.
	// void
	retPtr := gdnative.NewEmptyVoid()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

}

/*
        Specify weight values for next Vertex to use. Array must contain 4 values.
	Args: [{ false weights PoolRealArray}], Returns: void
*/
func (o *SurfaceTool) AddWeights(weights gdnative.PoolRealArray) {
	//log.Println("Calling SurfaceTool.AddWeights()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 1, 1)
	ptrArguments[0] = gdnative.NewPointerFromPoolRealArray(weights)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("SurfaceTool", "add_weights")

	// Call the parent method.
	// void
	retPtr := gdnative.NewEmptyVoid()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

}

/*
        Append vertices from a given [Mesh] surface onto the current vertex array with specified [Transform].
	Args: [{ false existing Mesh} { false surface int} { false transform Transform}], Returns: void
*/
func (o *SurfaceTool) AppendFrom(existing MeshImplementer, surface gdnative.Int, transform gdnative.Transform) {
	//log.Println("Calling SurfaceTool.AppendFrom()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 3, 3)
	ptrArguments[0] = gdnative.NewPointerFromObject(existing.GetBaseObject())
	ptrArguments[1] = gdnative.NewPointerFromInt(surface)
	ptrArguments[2] = gdnative.NewPointerFromTransform(transform)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("SurfaceTool", "append_from")

	// Call the parent method.
	// void
	retPtr := gdnative.NewEmptyVoid()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

}

/*
        Called before adding any Vertices. Takes the primitive type as an argument (e.g. Mesh.PRIMITIVE_TRIANGLES).
	Args: [{ false primitive int}], Returns: void
*/
func (o *SurfaceTool) Begin(primitive gdnative.Int) {
	//log.Println("Calling SurfaceTool.Begin()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 1, 1)
	ptrArguments[0] = gdnative.NewPointerFromInt(primitive)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("SurfaceTool", "begin")

	// Call the parent method.
	// void
	retPtr := gdnative.NewEmptyVoid()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

}

/*
        Clear all information passed into the surface tool so far.
	Args: [], Returns: void
*/
func (o *SurfaceTool) Clear() {
	//log.Println("Calling SurfaceTool.Clear()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 0, 0)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("SurfaceTool", "clear")

	// Call the parent method.
	// void
	retPtr := gdnative.NewEmptyVoid()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

}

/*
        Returns a constructed [ArrayMesh] from current information passed in. If an existing [ArrayMesh] is passed in as an argument, will add an extra surface to the existing [ArrayMesh].
	Args: [{Null true existing ArrayMesh} {97280 true flags int}], Returns: ArrayMesh
*/
func (o *SurfaceTool) Commit(existing ArrayMeshImplementer, flags gdnative.Int) ArrayMeshImplementer {
	//log.Println("Calling SurfaceTool.Commit()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 2, 2)
	ptrArguments[0] = gdnative.NewPointerFromObject(existing.GetBaseObject())
	ptrArguments[1] = gdnative.NewPointerFromInt(flags)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("SurfaceTool", "commit")

	// Call the parent method.
	// ArrayMesh
	retPtr := gdnative.NewEmptyObject()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := newArrayMeshFromPointer(retPtr)

	// Check to see if we already have an instance of this object in our Go instance registry.
	if instance, ok := InstanceRegistry.Get(ret.GetBaseObject().ID()); ok {
		return instance.(ArrayMeshImplementer)
	}

	// Check to see what kind of class this is and create it. This is generally used with
	// GetNode().
	className := ret.GetClass()
	if className != "ArrayMesh" {
		actualRet := getActualClass(className, ret.GetBaseObject())
		return actualRet.(ArrayMeshImplementer)
	}

	return &ret
}

/*
        Creates a vertex array from an existing [Mesh].
	Args: [{ false existing Mesh} { false surface int}], Returns: void
*/
func (o *SurfaceTool) CreateFrom(existing MeshImplementer, surface gdnative.Int) {
	//log.Println("Calling SurfaceTool.CreateFrom()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 2, 2)
	ptrArguments[0] = gdnative.NewPointerFromObject(existing.GetBaseObject())
	ptrArguments[1] = gdnative.NewPointerFromInt(surface)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("SurfaceTool", "create_from")

	// Call the parent method.
	// void
	retPtr := gdnative.NewEmptyVoid()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

}

/*
        Removes index array by expanding Vertex array.
	Args: [], Returns: void
*/
func (o *SurfaceTool) Deindex() {
	//log.Println("Calling SurfaceTool.Deindex()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 0, 0)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("SurfaceTool", "deindex")

	// Call the parent method.
	// void
	retPtr := gdnative.NewEmptyVoid()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

}

/*
        Generates normals from Vertices so you do not have to do it manually. Setting "flip" [code]true[/code] inverts resulting normals. Requires primitive type to be set to [code]PRIMITIVE_TRIANGLES[/code].
	Args: [{False true flip bool}], Returns: void
*/
func (o *SurfaceTool) GenerateNormals(flip gdnative.Bool) {
	//log.Println("Calling SurfaceTool.GenerateNormals()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 1, 1)
	ptrArguments[0] = gdnative.NewPointerFromBool(flip)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("SurfaceTool", "generate_normals")

	// Call the parent method.
	// void
	retPtr := gdnative.NewEmptyVoid()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

}

/*
        Generates a tangent vector for each vertex. Requires that each vertex have UVs and normals set already.
	Args: [], Returns: void
*/
func (o *SurfaceTool) GenerateTangents() {
	//log.Println("Calling SurfaceTool.GenerateTangents()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 0, 0)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("SurfaceTool", "generate_tangents")

	// Call the parent method.
	// void
	retPtr := gdnative.NewEmptyVoid()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

}

/*
        Shrinks Vertex array by creating an index array. Avoids reusing Vertices.
	Args: [], Returns: void
*/
func (o *SurfaceTool) Index() {
	//log.Println("Calling SurfaceTool.Index()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 0, 0)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("SurfaceTool", "index")

	// Call the parent method.
	// void
	retPtr := gdnative.NewEmptyVoid()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

}

/*
        Sets [Material] to be used by the [Mesh] you are constructing.
	Args: [{ false material Material}], Returns: void
*/
func (o *SurfaceTool) SetMaterial(material MaterialImplementer) {
	//log.Println("Calling SurfaceTool.SetMaterial()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 1, 1)
	ptrArguments[0] = gdnative.NewPointerFromObject(material.GetBaseObject())

	// Get the method bind
	methodBind := gdnative.NewMethodBind("SurfaceTool", "set_material")

	// Call the parent method.
	// void
	retPtr := gdnative.NewEmptyVoid()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

}

// SurfaceToolImplementer is an interface that implements the methods
// of the SurfaceTool class.
type SurfaceToolImplementer interface {
	ReferenceImplementer
	AddBones(bones gdnative.PoolIntArray)
	AddColor(color gdnative.Color)
	AddIndex(index gdnative.Int)
	AddNormal(normal gdnative.Vector3)
	AddSmoothGroup(smooth gdnative.Bool)
	AddTangent(tangent gdnative.Plane)
	AddTriangleFan(vertices gdnative.PoolVector3Array, uvs gdnative.PoolVector2Array, colors gdnative.PoolColorArray, uv2S gdnative.PoolVector2Array, normals gdnative.PoolVector3Array, tangents gdnative.Array)
	AddUv(uv gdnative.Vector2)
	AddUv2(uv2 gdnative.Vector2)
	AddVertex(vertex gdnative.Vector3)
	AddWeights(weights gdnative.PoolRealArray)
	AppendFrom(existing MeshImplementer, surface gdnative.Int, transform gdnative.Transform)
	Begin(primitive gdnative.Int)
	Clear()
	Commit(existing ArrayMeshImplementer, flags gdnative.Int) ArrayMeshImplementer
	CreateFrom(existing MeshImplementer, surface gdnative.Int)
	Deindex()
	GenerateNormals(flip gdnative.Bool)
	GenerateTangents()
	Index()
	SetMaterial(material MaterialImplementer)
}
