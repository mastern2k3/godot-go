package godot

import (
	"github.com/shadowapex/godot-go/gdnative"
)

/*------------------------------------------------------------------------------
//   This code was generated by a tool.
//
//   Changes to this file may cause incorrect behavior and will be lost if
//   the code is regenerated. Any updates should be done in
//   "class.go.tmpl" so they can be included in the generated
//   code.
//----------------------------------------------------------------------------*/

// TileMapHalfOffset is an enum for HalfOffset values.
type TileMapHalfOffset int

const (
	TileMapHalfOffsetDisabled TileMapHalfOffset = 2
	TileMapHalfOffsetX        TileMapHalfOffset = 0
	TileMapHalfOffsetY        TileMapHalfOffset = 1
)

// TileMapMode is an enum for Mode values.
type TileMapMode int

const (
	TileMapModeCustom    TileMapMode = 2
	TileMapModeIsometric TileMapMode = 1
	TileMapModeSquare    TileMapMode = 0
)

// TileMapTileOrigin is an enum for TileOrigin values.
type TileMapTileOrigin int

const (
	TileMapTileOriginBottomLeft TileMapTileOrigin = 2
	TileMapTileOriginCenter     TileMapTileOrigin = 1
	TileMapTileOriginTopLeft    TileMapTileOrigin = 0
)

//func NewTileMapFromPointer(ptr gdnative.Pointer) TileMap {
func newTileMapFromPointer(ptr gdnative.Pointer) TileMap {
	owner := gdnative.NewObjectFromPointer(ptr)
	obj := TileMap{}
	obj.SetBaseObject(owner)

	return obj
}

/*
Node for 2D tile-based maps. Tilemaps use a [TileSet] which contain a list of tiles (textures plus optional collision, navigation, and/or occluder shapes) which are used to create grid-based maps.
*/
type TileMap struct {
	Node2D
	owner gdnative.Object
}

func (o *TileMap) BaseClass() string {
	return "TileMap"
}

/*
        Undocumented
	Args: [], Returns: void
*/
func (o *TileMap) X_ClearQuadrants() {
	//log.Println("Calling TileMap.X_ClearQuadrants()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 0, 0)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("TileMap", "_clear_quadrants")

	// Call the parent method.
	// void
	retPtr := gdnative.NewEmptyVoid()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

}

/*
        Undocumented
	Args: [], Returns: int
*/
func (o *TileMap) X_GetOldCellSize() gdnative.Int {
	//log.Println("Calling TileMap.X_GetOldCellSize()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 0, 0)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("TileMap", "_get_old_cell_size")

	// Call the parent method.
	// int
	retPtr := gdnative.NewEmptyInt()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := gdnative.NewIntFromPointer(retPtr)
	return ret
}

/*
        Undocumented
	Args: [], Returns: PoolIntArray
*/
func (o *TileMap) X_GetTileData() gdnative.PoolIntArray {
	//log.Println("Calling TileMap.X_GetTileData()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 0, 0)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("TileMap", "_get_tile_data")

	// Call the parent method.
	// PoolIntArray
	retPtr := gdnative.NewEmptyPoolIntArray()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := gdnative.NewPoolIntArrayFromPointer(retPtr)
	return ret
}

/*
        Undocumented
	Args: [], Returns: void
*/
func (o *TileMap) X_RecreateQuadrants() {
	//log.Println("Calling TileMap.X_RecreateQuadrants()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 0, 0)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("TileMap", "_recreate_quadrants")

	// Call the parent method.
	// void
	retPtr := gdnative.NewEmptyVoid()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

}

/*
        Undocumented
	Args: [{ false position Vector2} { false data Dictionary}], Returns: void
*/
func (o *TileMap) X_SetCelld(position gdnative.Vector2, data gdnative.Dictionary) {
	//log.Println("Calling TileMap.X_SetCelld()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 2, 2)
	ptrArguments[0] = gdnative.NewPointerFromVector2(position)
	ptrArguments[1] = gdnative.NewPointerFromDictionary(data)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("TileMap", "_set_celld")

	// Call the parent method.
	// void
	retPtr := gdnative.NewEmptyVoid()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

}

/*
        Undocumented
	Args: [{ false size int}], Returns: void
*/
func (o *TileMap) X_SetOldCellSize(size gdnative.Int) {
	//log.Println("Calling TileMap.X_SetOldCellSize()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 1, 1)
	ptrArguments[0] = gdnative.NewPointerFromInt(size)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("TileMap", "_set_old_cell_size")

	// Call the parent method.
	// void
	retPtr := gdnative.NewEmptyVoid()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

}

/*
        Undocumented
	Args: [{ false arg0 PoolIntArray}], Returns: void
*/
func (o *TileMap) X_SetTileData(arg0 gdnative.PoolIntArray) {
	//log.Println("Calling TileMap.X_SetTileData()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 1, 1)
	ptrArguments[0] = gdnative.NewPointerFromPoolIntArray(arg0)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("TileMap", "_set_tile_data")

	// Call the parent method.
	// void
	retPtr := gdnative.NewEmptyVoid()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

}

/*
        Clears all cells.
	Args: [], Returns: void
*/
func (o *TileMap) Clear() {
	//log.Println("Calling TileMap.Clear()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 0, 0)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("TileMap", "clear")

	// Call the parent method.
	// void
	retPtr := gdnative.NewEmptyVoid()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

}

/*
        Clears cells that do not exist in the tileset.
	Args: [], Returns: void
*/
func (o *TileMap) FixInvalidTiles() {
	//log.Println("Calling TileMap.FixInvalidTiles()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 0, 0)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("TileMap", "fix_invalid_tiles")

	// Call the parent method.
	// void
	retPtr := gdnative.NewEmptyVoid()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

}

/*
        Returns the tile index of the given cell. If no tile exists in the cell, returns [constant INVALID_CELL].
	Args: [{ false x int} { false y int}], Returns: int
*/
func (o *TileMap) GetCell(x gdnative.Int, y gdnative.Int) gdnative.Int {
	//log.Println("Calling TileMap.GetCell()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 2, 2)
	ptrArguments[0] = gdnative.NewPointerFromInt(x)
	ptrArguments[1] = gdnative.NewPointerFromInt(y)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("TileMap", "get_cell")

	// Call the parent method.
	// int
	retPtr := gdnative.NewEmptyInt()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := gdnative.NewIntFromPointer(retPtr)
	return ret
}

/*

	Args: [{ false x int} { false y int}], Returns: Vector2
*/
func (o *TileMap) GetCellAutotileCoord(x gdnative.Int, y gdnative.Int) gdnative.Vector2 {
	//log.Println("Calling TileMap.GetCellAutotileCoord()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 2, 2)
	ptrArguments[0] = gdnative.NewPointerFromInt(x)
	ptrArguments[1] = gdnative.NewPointerFromInt(y)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("TileMap", "get_cell_autotile_coord")

	// Call the parent method.
	// Vector2
	retPtr := gdnative.NewEmptyVector2()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := gdnative.NewVector2FromPointer(retPtr)
	return ret
}

/*
        Undocumented
	Args: [], Returns: Vector2
*/
func (o *TileMap) GetCellSize() gdnative.Vector2 {
	//log.Println("Calling TileMap.GetCellSize()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 0, 0)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("TileMap", "get_cell_size")

	// Call the parent method.
	// Vector2
	retPtr := gdnative.NewEmptyVector2()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := gdnative.NewVector2FromPointer(retPtr)
	return ret
}

/*
        Returns the tile index of the cell given by a Vector2. If no tile exists in the cell, returns [constant INVALID_CELL].
	Args: [{ false position Vector2}], Returns: int
*/
func (o *TileMap) GetCellv(position gdnative.Vector2) gdnative.Int {
	//log.Println("Calling TileMap.GetCellv()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 1, 1)
	ptrArguments[0] = gdnative.NewPointerFromVector2(position)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("TileMap", "get_cellv")

	// Call the parent method.
	// int
	retPtr := gdnative.NewEmptyInt()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := gdnative.NewIntFromPointer(retPtr)
	return ret
}

/*
        Undocumented
	Args: [], Returns: bool
*/
func (o *TileMap) GetClipUv() gdnative.Bool {
	//log.Println("Calling TileMap.GetClipUv()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 0, 0)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("TileMap", "get_clip_uv")

	// Call the parent method.
	// bool
	retPtr := gdnative.NewEmptyBool()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := gdnative.NewBoolFromPointer(retPtr)
	return ret
}

/*
        Undocumented
	Args: [], Returns: float
*/
func (o *TileMap) GetCollisionBounce() gdnative.Real {
	//log.Println("Calling TileMap.GetCollisionBounce()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 0, 0)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("TileMap", "get_collision_bounce")

	// Call the parent method.
	// float
	retPtr := gdnative.NewEmptyReal()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := gdnative.NewRealFromPointer(retPtr)
	return ret
}

/*
        Undocumented
	Args: [], Returns: float
*/
func (o *TileMap) GetCollisionFriction() gdnative.Real {
	//log.Println("Calling TileMap.GetCollisionFriction()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 0, 0)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("TileMap", "get_collision_friction")

	// Call the parent method.
	// float
	retPtr := gdnative.NewEmptyReal()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := gdnative.NewRealFromPointer(retPtr)
	return ret
}

/*
        Undocumented
	Args: [], Returns: int
*/
func (o *TileMap) GetCollisionLayer() gdnative.Int {
	//log.Println("Calling TileMap.GetCollisionLayer()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 0, 0)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("TileMap", "get_collision_layer")

	// Call the parent method.
	// int
	retPtr := gdnative.NewEmptyInt()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := gdnative.NewIntFromPointer(retPtr)
	return ret
}

/*
        Returns [code]true[/code] if the given collision layer bit is set.
	Args: [{ false bit int}], Returns: bool
*/
func (o *TileMap) GetCollisionLayerBit(bit gdnative.Int) gdnative.Bool {
	//log.Println("Calling TileMap.GetCollisionLayerBit()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 1, 1)
	ptrArguments[0] = gdnative.NewPointerFromInt(bit)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("TileMap", "get_collision_layer_bit")

	// Call the parent method.
	// bool
	retPtr := gdnative.NewEmptyBool()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := gdnative.NewBoolFromPointer(retPtr)
	return ret
}

/*
        Undocumented
	Args: [], Returns: int
*/
func (o *TileMap) GetCollisionMask() gdnative.Int {
	//log.Println("Calling TileMap.GetCollisionMask()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 0, 0)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("TileMap", "get_collision_mask")

	// Call the parent method.
	// int
	retPtr := gdnative.NewEmptyInt()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := gdnative.NewIntFromPointer(retPtr)
	return ret
}

/*
        Returns [code]true[/code] if the given collision mask bit is set.
	Args: [{ false bit int}], Returns: bool
*/
func (o *TileMap) GetCollisionMaskBit(bit gdnative.Int) gdnative.Bool {
	//log.Println("Calling TileMap.GetCollisionMaskBit()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 1, 1)
	ptrArguments[0] = gdnative.NewPointerFromInt(bit)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("TileMap", "get_collision_mask_bit")

	// Call the parent method.
	// bool
	retPtr := gdnative.NewEmptyBool()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := gdnative.NewBoolFromPointer(retPtr)
	return ret
}

/*
        Undocumented
	Args: [], Returns: bool
*/
func (o *TileMap) GetCollisionUseKinematic() gdnative.Bool {
	//log.Println("Calling TileMap.GetCollisionUseKinematic()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 0, 0)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("TileMap", "get_collision_use_kinematic")

	// Call the parent method.
	// bool
	retPtr := gdnative.NewEmptyBool()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := gdnative.NewBoolFromPointer(retPtr)
	return ret
}

/*
        Undocumented
	Args: [], Returns: Transform2D
*/
func (o *TileMap) GetCustomTransform() gdnative.Transform2D {
	//log.Println("Calling TileMap.GetCustomTransform()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 0, 0)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("TileMap", "get_custom_transform")

	// Call the parent method.
	// Transform2D
	retPtr := gdnative.NewEmptyTransform2D()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := gdnative.NewTransform2DFromPointer(retPtr)
	return ret
}

/*
        Undocumented
	Args: [], Returns: enum.TileMap::HalfOffset
*/
func (o *TileMap) GetHalfOffset() TileMapHalfOffset {
	//log.Println("Calling TileMap.GetHalfOffset()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 0, 0)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("TileMap", "get_half_offset")

	// Call the parent method.
	// enum.TileMap::HalfOffset
	retPtr := gdnative.NewEmptyInt()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := gdnative.NewIntFromPointer(retPtr)
	return TileMapHalfOffset(ret)
}

/*
        Undocumented
	Args: [], Returns: enum.TileMap::Mode
*/
func (o *TileMap) GetMode() TileMapMode {
	//log.Println("Calling TileMap.GetMode()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 0, 0)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("TileMap", "get_mode")

	// Call the parent method.
	// enum.TileMap::Mode
	retPtr := gdnative.NewEmptyInt()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := gdnative.NewIntFromPointer(retPtr)
	return TileMapMode(ret)
}

/*
        Undocumented
	Args: [], Returns: int
*/
func (o *TileMap) GetOccluderLightMask() gdnative.Int {
	//log.Println("Calling TileMap.GetOccluderLightMask()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 0, 0)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("TileMap", "get_occluder_light_mask")

	// Call the parent method.
	// int
	retPtr := gdnative.NewEmptyInt()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := gdnative.NewIntFromPointer(retPtr)
	return ret
}

/*
        Undocumented
	Args: [], Returns: int
*/
func (o *TileMap) GetQuadrantSize() gdnative.Int {
	//log.Println("Calling TileMap.GetQuadrantSize()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 0, 0)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("TileMap", "get_quadrant_size")

	// Call the parent method.
	// int
	retPtr := gdnative.NewEmptyInt()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := gdnative.NewIntFromPointer(retPtr)
	return ret
}

/*
        Undocumented
	Args: [], Returns: enum.TileMap::TileOrigin
*/
func (o *TileMap) GetTileOrigin() TileMapTileOrigin {
	//log.Println("Calling TileMap.GetTileOrigin()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 0, 0)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("TileMap", "get_tile_origin")

	// Call the parent method.
	// enum.TileMap::TileOrigin
	retPtr := gdnative.NewEmptyInt()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := gdnative.NewIntFromPointer(retPtr)
	return TileMapTileOrigin(ret)
}

/*
        Undocumented
	Args: [], Returns: TileSet
*/
func (o *TileMap) GetTileset() TileSetImplementer {
	//log.Println("Calling TileMap.GetTileset()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 0, 0)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("TileMap", "get_tileset")

	// Call the parent method.
	// TileSet
	retPtr := gdnative.NewEmptyObject()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := newTileSetFromPointer(retPtr)

	// Check to see if we already have an instance of this object in our Go instance registry.
	if instance, ok := InstanceRegistry.Get(ret.GetBaseObject().ID()); ok {
		return instance.(TileSetImplementer)
	}

	// Check to see what kind of class this is and create it. This is generally used with
	// GetNode().
	className := ret.GetClass()
	if className != "TileSet" {
		actualRet := getActualClass(className, ret.GetBaseObject())
		return actualRet.(TileSetImplementer)
	}

	return &ret
}

/*
        Returns a [Vector2] array with the positions of all cells containing a tile from the tileset (i.e. a tile index different from [code]-1[/code]).
	Args: [], Returns: Array
*/
func (o *TileMap) GetUsedCells() gdnative.Array {
	//log.Println("Calling TileMap.GetUsedCells()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 0, 0)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("TileMap", "get_used_cells")

	// Call the parent method.
	// Array
	retPtr := gdnative.NewEmptyArray()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := gdnative.NewArrayFromPointer(retPtr)
	return ret
}

/*
        Returns an array of all cells with the given tile id.
	Args: [{ false id int}], Returns: Array
*/
func (o *TileMap) GetUsedCellsById(id gdnative.Int) gdnative.Array {
	//log.Println("Calling TileMap.GetUsedCellsById()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 1, 1)
	ptrArguments[0] = gdnative.NewPointerFromInt(id)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("TileMap", "get_used_cells_by_id")

	// Call the parent method.
	// Array
	retPtr := gdnative.NewEmptyArray()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := gdnative.NewArrayFromPointer(retPtr)
	return ret
}

/*
        Returns a rectangle enclosing the used (non-empty) tiles of the map.
	Args: [], Returns: Rect2
*/
func (o *TileMap) GetUsedRect() gdnative.Rect2 {
	//log.Println("Calling TileMap.GetUsedRect()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 0, 0)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("TileMap", "get_used_rect")

	// Call the parent method.
	// Rect2
	retPtr := gdnative.NewEmptyRect2()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := gdnative.NewRect2FromPointer(retPtr)
	return ret
}

/*
        Returns [code]true[/code] if the given cell is transposed, i.e. the x and y axes are swapped.
	Args: [{ false x int} { false y int}], Returns: bool
*/
func (o *TileMap) IsCellTransposed(x gdnative.Int, y gdnative.Int) gdnative.Bool {
	//log.Println("Calling TileMap.IsCellTransposed()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 2, 2)
	ptrArguments[0] = gdnative.NewPointerFromInt(x)
	ptrArguments[1] = gdnative.NewPointerFromInt(y)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("TileMap", "is_cell_transposed")

	// Call the parent method.
	// bool
	retPtr := gdnative.NewEmptyBool()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := gdnative.NewBoolFromPointer(retPtr)
	return ret
}

/*
        Returns [code]true[/code] if the given cell is flipped in the x axis.
	Args: [{ false x int} { false y int}], Returns: bool
*/
func (o *TileMap) IsCellXFlipped(x gdnative.Int, y gdnative.Int) gdnative.Bool {
	//log.Println("Calling TileMap.IsCellXFlipped()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 2, 2)
	ptrArguments[0] = gdnative.NewPointerFromInt(x)
	ptrArguments[1] = gdnative.NewPointerFromInt(y)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("TileMap", "is_cell_x_flipped")

	// Call the parent method.
	// bool
	retPtr := gdnative.NewEmptyBool()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := gdnative.NewBoolFromPointer(retPtr)
	return ret
}

/*
        Returns [code]true[/code] if the given cell is flipped in the y axis.
	Args: [{ false x int} { false y int}], Returns: bool
*/
func (o *TileMap) IsCellYFlipped(x gdnative.Int, y gdnative.Int) gdnative.Bool {
	//log.Println("Calling TileMap.IsCellYFlipped()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 2, 2)
	ptrArguments[0] = gdnative.NewPointerFromInt(x)
	ptrArguments[1] = gdnative.NewPointerFromInt(y)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("TileMap", "is_cell_y_flipped")

	// Call the parent method.
	// bool
	retPtr := gdnative.NewEmptyBool()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := gdnative.NewBoolFromPointer(retPtr)
	return ret
}

/*
        Undocumented
	Args: [], Returns: bool
*/
func (o *TileMap) IsYSortModeEnabled() gdnative.Bool {
	//log.Println("Calling TileMap.IsYSortModeEnabled()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 0, 0)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("TileMap", "is_y_sort_mode_enabled")

	// Call the parent method.
	// bool
	retPtr := gdnative.NewEmptyBool()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := gdnative.NewBoolFromPointer(retPtr)
	return ret
}

/*
        Returns the global position corresponding to the given tilemap (grid-based) coordinates. Optionally, the tilemap's half offset can be ignored.
	Args: [{ false map_position Vector2} {False true ignore_half_ofs bool}], Returns: Vector2
*/
func (o *TileMap) MapToWorld(mapPosition gdnative.Vector2, ignoreHalfOfs gdnative.Bool) gdnative.Vector2 {
	//log.Println("Calling TileMap.MapToWorld()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 2, 2)
	ptrArguments[0] = gdnative.NewPointerFromVector2(mapPosition)
	ptrArguments[1] = gdnative.NewPointerFromBool(ignoreHalfOfs)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("TileMap", "map_to_world")

	// Call the parent method.
	// Vector2
	retPtr := gdnative.NewEmptyVector2()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := gdnative.NewVector2FromPointer(retPtr)
	return ret
}

/*
        Sets the tile index for the cell given by a Vector2. An index of [code]-1[/code] clears the cell. Optionally, the tile can also be flipped, transposed, or given autotile coordinates. Note that data such as navigation polygons and collision shapes are not immediately updated for performance reasons. If you need these to be immediately updated, you can call [method update_dirty_quadrants].
	Args: [{ false x int} { false y int} { false tile int} {False true flip_x bool} {False true flip_y bool} {False true transpose bool} {(0, 0) true autotile_coord Vector2}], Returns: void
*/
func (o *TileMap) SetCell(x gdnative.Int, y gdnative.Int, tile gdnative.Int, flipX gdnative.Bool, flipY gdnative.Bool, transpose gdnative.Bool, autotileCoord gdnative.Vector2) {
	//log.Println("Calling TileMap.SetCell()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 7, 7)
	ptrArguments[0] = gdnative.NewPointerFromInt(x)
	ptrArguments[1] = gdnative.NewPointerFromInt(y)
	ptrArguments[2] = gdnative.NewPointerFromInt(tile)
	ptrArguments[3] = gdnative.NewPointerFromBool(flipX)
	ptrArguments[4] = gdnative.NewPointerFromBool(flipY)
	ptrArguments[5] = gdnative.NewPointerFromBool(transpose)
	ptrArguments[6] = gdnative.NewPointerFromVector2(autotileCoord)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("TileMap", "set_cell")

	// Call the parent method.
	// void
	retPtr := gdnative.NewEmptyVoid()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

}

/*
        Undocumented
	Args: [{ false size Vector2}], Returns: void
*/
func (o *TileMap) SetCellSize(size gdnative.Vector2) {
	//log.Println("Calling TileMap.SetCellSize()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 1, 1)
	ptrArguments[0] = gdnative.NewPointerFromVector2(size)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("TileMap", "set_cell_size")

	// Call the parent method.
	// void
	retPtr := gdnative.NewEmptyVoid()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

}

/*
        Sets the tile index for the given cell. An index of [code]-1[/code] clears the cell. Optionally, the tile can also be flipped or transposed. Note that data such as navigation polygons and collision shapes are not immediately updated for performance reasons. If you need these to be immediately updated, you can call [method update_dirty_quadrants].
	Args: [{ false position Vector2} { false tile int} {False true flip_x bool} {False true flip_y bool} {False true transpose bool}], Returns: void
*/
func (o *TileMap) SetCellv(position gdnative.Vector2, tile gdnative.Int, flipX gdnative.Bool, flipY gdnative.Bool, transpose gdnative.Bool) {
	//log.Println("Calling TileMap.SetCellv()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 5, 5)
	ptrArguments[0] = gdnative.NewPointerFromVector2(position)
	ptrArguments[1] = gdnative.NewPointerFromInt(tile)
	ptrArguments[2] = gdnative.NewPointerFromBool(flipX)
	ptrArguments[3] = gdnative.NewPointerFromBool(flipY)
	ptrArguments[4] = gdnative.NewPointerFromBool(transpose)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("TileMap", "set_cellv")

	// Call the parent method.
	// void
	retPtr := gdnative.NewEmptyVoid()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

}

/*
        Undocumented
	Args: [{ false enable bool}], Returns: void
*/
func (o *TileMap) SetClipUv(enable gdnative.Bool) {
	//log.Println("Calling TileMap.SetClipUv()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 1, 1)
	ptrArguments[0] = gdnative.NewPointerFromBool(enable)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("TileMap", "set_clip_uv")

	// Call the parent method.
	// void
	retPtr := gdnative.NewEmptyVoid()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

}

/*
        Undocumented
	Args: [{ false value float}], Returns: void
*/
func (o *TileMap) SetCollisionBounce(value gdnative.Real) {
	//log.Println("Calling TileMap.SetCollisionBounce()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 1, 1)
	ptrArguments[0] = gdnative.NewPointerFromReal(value)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("TileMap", "set_collision_bounce")

	// Call the parent method.
	// void
	retPtr := gdnative.NewEmptyVoid()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

}

/*
        Undocumented
	Args: [{ false value float}], Returns: void
*/
func (o *TileMap) SetCollisionFriction(value gdnative.Real) {
	//log.Println("Calling TileMap.SetCollisionFriction()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 1, 1)
	ptrArguments[0] = gdnative.NewPointerFromReal(value)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("TileMap", "set_collision_friction")

	// Call the parent method.
	// void
	retPtr := gdnative.NewEmptyVoid()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

}

/*
        Undocumented
	Args: [{ false layer int}], Returns: void
*/
func (o *TileMap) SetCollisionLayer(layer gdnative.Int) {
	//log.Println("Calling TileMap.SetCollisionLayer()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 1, 1)
	ptrArguments[0] = gdnative.NewPointerFromInt(layer)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("TileMap", "set_collision_layer")

	// Call the parent method.
	// void
	retPtr := gdnative.NewEmptyVoid()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

}

/*
        Sets the given collision layer bit.
	Args: [{ false bit int} { false value bool}], Returns: void
*/
func (o *TileMap) SetCollisionLayerBit(bit gdnative.Int, value gdnative.Bool) {
	//log.Println("Calling TileMap.SetCollisionLayerBit()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 2, 2)
	ptrArguments[0] = gdnative.NewPointerFromInt(bit)
	ptrArguments[1] = gdnative.NewPointerFromBool(value)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("TileMap", "set_collision_layer_bit")

	// Call the parent method.
	// void
	retPtr := gdnative.NewEmptyVoid()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

}

/*
        Undocumented
	Args: [{ false mask int}], Returns: void
*/
func (o *TileMap) SetCollisionMask(mask gdnative.Int) {
	//log.Println("Calling TileMap.SetCollisionMask()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 1, 1)
	ptrArguments[0] = gdnative.NewPointerFromInt(mask)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("TileMap", "set_collision_mask")

	// Call the parent method.
	// void
	retPtr := gdnative.NewEmptyVoid()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

}

/*
        Sets the given collision mask bit.
	Args: [{ false bit int} { false value bool}], Returns: void
*/
func (o *TileMap) SetCollisionMaskBit(bit gdnative.Int, value gdnative.Bool) {
	//log.Println("Calling TileMap.SetCollisionMaskBit()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 2, 2)
	ptrArguments[0] = gdnative.NewPointerFromInt(bit)
	ptrArguments[1] = gdnative.NewPointerFromBool(value)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("TileMap", "set_collision_mask_bit")

	// Call the parent method.
	// void
	retPtr := gdnative.NewEmptyVoid()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

}

/*
        Undocumented
	Args: [{ false use_kinematic bool}], Returns: void
*/
func (o *TileMap) SetCollisionUseKinematic(useKinematic gdnative.Bool) {
	//log.Println("Calling TileMap.SetCollisionUseKinematic()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 1, 1)
	ptrArguments[0] = gdnative.NewPointerFromBool(useKinematic)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("TileMap", "set_collision_use_kinematic")

	// Call the parent method.
	// void
	retPtr := gdnative.NewEmptyVoid()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

}

/*
        Undocumented
	Args: [{ false custom_transform Transform2D}], Returns: void
*/
func (o *TileMap) SetCustomTransform(customTransform gdnative.Transform2D) {
	//log.Println("Calling TileMap.SetCustomTransform()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 1, 1)
	ptrArguments[0] = gdnative.NewPointerFromTransform2D(customTransform)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("TileMap", "set_custom_transform")

	// Call the parent method.
	// void
	retPtr := gdnative.NewEmptyVoid()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

}

/*
        Undocumented
	Args: [{ false half_offset int}], Returns: void
*/
func (o *TileMap) SetHalfOffset(halfOffset gdnative.Int) {
	//log.Println("Calling TileMap.SetHalfOffset()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 1, 1)
	ptrArguments[0] = gdnative.NewPointerFromInt(halfOffset)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("TileMap", "set_half_offset")

	// Call the parent method.
	// void
	retPtr := gdnative.NewEmptyVoid()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

}

/*
        Undocumented
	Args: [{ false mode int}], Returns: void
*/
func (o *TileMap) SetMode(mode gdnative.Int) {
	//log.Println("Calling TileMap.SetMode()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 1, 1)
	ptrArguments[0] = gdnative.NewPointerFromInt(mode)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("TileMap", "set_mode")

	// Call the parent method.
	// void
	retPtr := gdnative.NewEmptyVoid()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

}

/*
        Undocumented
	Args: [{ false mask int}], Returns: void
*/
func (o *TileMap) SetOccluderLightMask(mask gdnative.Int) {
	//log.Println("Calling TileMap.SetOccluderLightMask()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 1, 1)
	ptrArguments[0] = gdnative.NewPointerFromInt(mask)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("TileMap", "set_occluder_light_mask")

	// Call the parent method.
	// void
	retPtr := gdnative.NewEmptyVoid()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

}

/*
        Undocumented
	Args: [{ false size int}], Returns: void
*/
func (o *TileMap) SetQuadrantSize(size gdnative.Int) {
	//log.Println("Calling TileMap.SetQuadrantSize()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 1, 1)
	ptrArguments[0] = gdnative.NewPointerFromInt(size)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("TileMap", "set_quadrant_size")

	// Call the parent method.
	// void
	retPtr := gdnative.NewEmptyVoid()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

}

/*
        Undocumented
	Args: [{ false origin int}], Returns: void
*/
func (o *TileMap) SetTileOrigin(origin gdnative.Int) {
	//log.Println("Calling TileMap.SetTileOrigin()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 1, 1)
	ptrArguments[0] = gdnative.NewPointerFromInt(origin)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("TileMap", "set_tile_origin")

	// Call the parent method.
	// void
	retPtr := gdnative.NewEmptyVoid()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

}

/*
        Undocumented
	Args: [{ false tileset TileSet}], Returns: void
*/
func (o *TileMap) SetTileset(tileset TileSetImplementer) {
	//log.Println("Calling TileMap.SetTileset()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 1, 1)
	ptrArguments[0] = gdnative.NewPointerFromObject(tileset.GetBaseObject())

	// Get the method bind
	methodBind := gdnative.NewMethodBind("TileMap", "set_tileset")

	// Call the parent method.
	// void
	retPtr := gdnative.NewEmptyVoid()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

}

/*
        Undocumented
	Args: [{ false enable bool}], Returns: void
*/
func (o *TileMap) SetYSortMode(enable gdnative.Bool) {
	//log.Println("Calling TileMap.SetYSortMode()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 1, 1)
	ptrArguments[0] = gdnative.NewPointerFromBool(enable)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("TileMap", "set_y_sort_mode")

	// Call the parent method.
	// void
	retPtr := gdnative.NewEmptyVoid()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

}

/*
        Applies autotiling rules to the cell (and its adjacent cells) referenced by its grid-based x and y coordinates.
	Args: [{ false position Vector2}], Returns: void
*/
func (o *TileMap) UpdateBitmaskArea(position gdnative.Vector2) {
	//log.Println("Calling TileMap.UpdateBitmaskArea()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 1, 1)
	ptrArguments[0] = gdnative.NewPointerFromVector2(position)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("TileMap", "update_bitmask_area")

	// Call the parent method.
	// void
	retPtr := gdnative.NewEmptyVoid()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

}

/*
        Applies autotiling rules to the cells in the given region (specified by grid-based x and y coordinates). Calling with invalid (or missing) parameters applies autotiling rules for the entire tilemap.
	Args: [{(0, 0) true start Vector2} {(0, 0) true end Vector2}], Returns: void
*/
func (o *TileMap) UpdateBitmaskRegion(start gdnative.Vector2, end gdnative.Vector2) {
	//log.Println("Calling TileMap.UpdateBitmaskRegion()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 2, 2)
	ptrArguments[0] = gdnative.NewPointerFromVector2(start)
	ptrArguments[1] = gdnative.NewPointerFromVector2(end)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("TileMap", "update_bitmask_region")

	// Call the parent method.
	// void
	retPtr := gdnative.NewEmptyVoid()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

}

/*
        Updates the tile map's quadrants, allowing things such as navigation and collision shapes to be immediately used if modified.
	Args: [], Returns: void
*/
func (o *TileMap) UpdateDirtyQuadrants() {
	//log.Println("Calling TileMap.UpdateDirtyQuadrants()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 0, 0)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("TileMap", "update_dirty_quadrants")

	// Call the parent method.
	// void
	retPtr := gdnative.NewEmptyVoid()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

}

/*
        Returns the tilemap (grid-based) coordinates corresponding to the given local position.
	Args: [{ false world_position Vector2}], Returns: Vector2
*/
func (o *TileMap) WorldToMap(worldPosition gdnative.Vector2) gdnative.Vector2 {
	//log.Println("Calling TileMap.WorldToMap()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 1, 1)
	ptrArguments[0] = gdnative.NewPointerFromVector2(worldPosition)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("TileMap", "world_to_map")

	// Call the parent method.
	// Vector2
	retPtr := gdnative.NewEmptyVector2()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := gdnative.NewVector2FromPointer(retPtr)
	return ret
}

// TileMapImplementer is an interface that implements the methods
// of the TileMap class.
type TileMapImplementer interface {
	Node2DImplementer
	X_ClearQuadrants()
	X_GetOldCellSize() gdnative.Int
	X_GetTileData() gdnative.PoolIntArray
	X_RecreateQuadrants()
	X_SetCelld(position gdnative.Vector2, data gdnative.Dictionary)
	X_SetOldCellSize(size gdnative.Int)
	X_SetTileData(arg0 gdnative.PoolIntArray)
	Clear()
	FixInvalidTiles()
	GetCell(x gdnative.Int, y gdnative.Int) gdnative.Int
	GetCellAutotileCoord(x gdnative.Int, y gdnative.Int) gdnative.Vector2
	GetCellSize() gdnative.Vector2
	GetCellv(position gdnative.Vector2) gdnative.Int
	GetClipUv() gdnative.Bool
	GetCollisionBounce() gdnative.Real
	GetCollisionFriction() gdnative.Real
	GetCollisionLayer() gdnative.Int
	GetCollisionLayerBit(bit gdnative.Int) gdnative.Bool
	GetCollisionMask() gdnative.Int
	GetCollisionMaskBit(bit gdnative.Int) gdnative.Bool
	GetCollisionUseKinematic() gdnative.Bool
	GetCustomTransform() gdnative.Transform2D
	GetOccluderLightMask() gdnative.Int
	GetQuadrantSize() gdnative.Int
	GetTileset() TileSetImplementer
	GetUsedCells() gdnative.Array
	GetUsedCellsById(id gdnative.Int) gdnative.Array
	GetUsedRect() gdnative.Rect2
	IsCellTransposed(x gdnative.Int, y gdnative.Int) gdnative.Bool
	IsCellXFlipped(x gdnative.Int, y gdnative.Int) gdnative.Bool
	IsCellYFlipped(x gdnative.Int, y gdnative.Int) gdnative.Bool
	IsYSortModeEnabled() gdnative.Bool
	MapToWorld(mapPosition gdnative.Vector2, ignoreHalfOfs gdnative.Bool) gdnative.Vector2
	SetCell(x gdnative.Int, y gdnative.Int, tile gdnative.Int, flipX gdnative.Bool, flipY gdnative.Bool, transpose gdnative.Bool, autotileCoord gdnative.Vector2)
	SetCellSize(size gdnative.Vector2)
	SetCellv(position gdnative.Vector2, tile gdnative.Int, flipX gdnative.Bool, flipY gdnative.Bool, transpose gdnative.Bool)
	SetClipUv(enable gdnative.Bool)
	SetCollisionBounce(value gdnative.Real)
	SetCollisionFriction(value gdnative.Real)
	SetCollisionLayer(layer gdnative.Int)
	SetCollisionLayerBit(bit gdnative.Int, value gdnative.Bool)
	SetCollisionMask(mask gdnative.Int)
	SetCollisionMaskBit(bit gdnative.Int, value gdnative.Bool)
	SetCollisionUseKinematic(useKinematic gdnative.Bool)
	SetCustomTransform(customTransform gdnative.Transform2D)
	SetHalfOffset(halfOffset gdnative.Int)
	SetMode(mode gdnative.Int)
	SetOccluderLightMask(mask gdnative.Int)
	SetQuadrantSize(size gdnative.Int)
	SetTileOrigin(origin gdnative.Int)
	SetTileset(tileset TileSetImplementer)
	SetYSortMode(enable gdnative.Bool)
	UpdateBitmaskArea(position gdnative.Vector2)
	UpdateBitmaskRegion(start gdnative.Vector2, end gdnative.Vector2)
	UpdateDirtyQuadrants()
	WorldToMap(worldPosition gdnative.Vector2) gdnative.Vector2
}
