package godot

import (
	"github.com/shadowapex/godot-go/gdnative"
)

/*------------------------------------------------------------------------------
//   This code was generated by a tool.
//
//   Changes to this file may cause incorrect behavior and will be lost if
//   the code is regenerated. Any updates should be done in
//   "class.go.tmpl" so they can be included in the generated
//   code.
//----------------------------------------------------------------------------*/

// MultiplayerAPIRPCMode is an enum for RPCMode values.
type MultiplayerAPIRPCMode int

const (
	MultiplayerAPIRpcModeDisabled   MultiplayerAPIRPCMode = 0
	MultiplayerAPIRpcModeMaster     MultiplayerAPIRPCMode = 2
	MultiplayerAPIRpcModeMastersync MultiplayerAPIRPCMode = 5
	MultiplayerAPIRpcModePuppet     MultiplayerAPIRPCMode = 3
	MultiplayerAPIRpcModePuppetsync MultiplayerAPIRPCMode = 6
	MultiplayerAPIRpcModeRemote     MultiplayerAPIRPCMode = 1
	MultiplayerAPIRpcModeRemotesync MultiplayerAPIRPCMode = 4
	MultiplayerAPIRpcModeSlave      MultiplayerAPIRPCMode = 3
	MultiplayerAPIRpcModeSync       MultiplayerAPIRPCMode = 4
)

//func NewMultiplayerAPIFromPointer(ptr gdnative.Pointer) MultiplayerAPI {
func newMultiplayerAPIFromPointer(ptr gdnative.Pointer) MultiplayerAPI {
	owner := gdnative.NewObjectFromPointer(ptr)
	obj := MultiplayerAPI{}
	obj.SetBaseObject(owner)

	return obj
}

/*
This class implements most of the logic behind the high level multiplayer API. By default, [SceneTree] has a reference to this class that is used to provide multiplayer capabilities (i.e. RPC/RSET) across the whole scene. It is possible to override the MultiplayerAPI instance used by specific Nodes by setting the [member Node.custom_multiplayer] property, effectively allowing to run both client and server in the same scene.
*/
type MultiplayerAPI struct {
	Reference
	owner gdnative.Object
}

func (o *MultiplayerAPI) BaseClass() string {
	return "MultiplayerAPI"
}

/*
        Undocumented
	Args: [{ false id int}], Returns: void
*/
func (o *MultiplayerAPI) X_AddPeer(id gdnative.Int) {
	//log.Println("Calling MultiplayerAPI.X_AddPeer()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 1, 1)
	ptrArguments[0] = gdnative.NewPointerFromInt(id)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("MultiplayerAPI", "_add_peer")

	// Call the parent method.
	// void
	retPtr := gdnative.NewEmptyVoid()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

}

/*
        Undocumented
	Args: [], Returns: void
*/
func (o *MultiplayerAPI) X_ConnectedToServer() {
	//log.Println("Calling MultiplayerAPI.X_ConnectedToServer()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 0, 0)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("MultiplayerAPI", "_connected_to_server")

	// Call the parent method.
	// void
	retPtr := gdnative.NewEmptyVoid()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

}

/*
        Undocumented
	Args: [], Returns: void
*/
func (o *MultiplayerAPI) X_ConnectionFailed() {
	//log.Println("Calling MultiplayerAPI.X_ConnectionFailed()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 0, 0)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("MultiplayerAPI", "_connection_failed")

	// Call the parent method.
	// void
	retPtr := gdnative.NewEmptyVoid()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

}

/*
        Undocumented
	Args: [{ false id int}], Returns: void
*/
func (o *MultiplayerAPI) X_DelPeer(id gdnative.Int) {
	//log.Println("Calling MultiplayerAPI.X_DelPeer()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 1, 1)
	ptrArguments[0] = gdnative.NewPointerFromInt(id)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("MultiplayerAPI", "_del_peer")

	// Call the parent method.
	// void
	retPtr := gdnative.NewEmptyVoid()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

}

/*
        Undocumented
	Args: [], Returns: void
*/
func (o *MultiplayerAPI) X_ServerDisconnected() {
	//log.Println("Calling MultiplayerAPI.X_ServerDisconnected()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 0, 0)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("MultiplayerAPI", "_server_disconnected")

	// Call the parent method.
	// void
	retPtr := gdnative.NewEmptyVoid()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

}

/*
        Clears the current MultiplayerAPI network state (you shouldn't call this unless you know what you are doing).
	Args: [], Returns: void
*/
func (o *MultiplayerAPI) Clear() {
	//log.Println("Calling MultiplayerAPI.Clear()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 0, 0)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("MultiplayerAPI", "clear")

	// Call the parent method.
	// void
	retPtr := gdnative.NewEmptyVoid()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

}

/*
        Returns the peer IDs of all connected peers of this MultiplayerAPI's [member network_peer].
	Args: [], Returns: PoolIntArray
*/
func (o *MultiplayerAPI) GetNetworkConnectedPeers() gdnative.PoolIntArray {
	//log.Println("Calling MultiplayerAPI.GetNetworkConnectedPeers()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 0, 0)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("MultiplayerAPI", "get_network_connected_peers")

	// Call the parent method.
	// PoolIntArray
	retPtr := gdnative.NewEmptyPoolIntArray()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := gdnative.NewPoolIntArrayFromPointer(retPtr)
	return ret
}

/*
        Undocumented
	Args: [], Returns: NetworkedMultiplayerPeer
*/
func (o *MultiplayerAPI) GetNetworkPeer() NetworkedMultiplayerPeerImplementer {
	//log.Println("Calling MultiplayerAPI.GetNetworkPeer()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 0, 0)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("MultiplayerAPI", "get_network_peer")

	// Call the parent method.
	// NetworkedMultiplayerPeer
	retPtr := gdnative.NewEmptyObject()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := newNetworkedMultiplayerPeerFromPointer(retPtr)

	// Check to see if we already have an instance of this object in our Go instance registry.
	if instance, ok := InstanceRegistry.Get(ret.GetBaseObject().ID()); ok {
		return instance.(NetworkedMultiplayerPeerImplementer)
	}

	// Check to see what kind of class this is and create it. This is generally used with
	// GetNode().
	className := ret.GetClass()
	if className != "NetworkedMultiplayerPeer" {
		actualRet := getActualClass(className, ret.GetBaseObject())
		return actualRet.(NetworkedMultiplayerPeerImplementer)
	}

	return &ret
}

/*
        Returns the unique peer ID of this MultiplayerAPI's [member network_peer].
	Args: [], Returns: int
*/
func (o *MultiplayerAPI) GetNetworkUniqueId() gdnative.Int {
	//log.Println("Calling MultiplayerAPI.GetNetworkUniqueId()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 0, 0)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("MultiplayerAPI", "get_network_unique_id")

	// Call the parent method.
	// int
	retPtr := gdnative.NewEmptyInt()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := gdnative.NewIntFromPointer(retPtr)
	return ret
}

/*
        Returns the sender's peer ID for the RPC currently being executed. NOTE: If not inside an RPC this method will return 0.
	Args: [], Returns: int
*/
func (o *MultiplayerAPI) GetRpcSenderId() gdnative.Int {
	//log.Println("Calling MultiplayerAPI.GetRpcSenderId()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 0, 0)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("MultiplayerAPI", "get_rpc_sender_id")

	// Call the parent method.
	// int
	retPtr := gdnative.NewEmptyInt()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := gdnative.NewIntFromPointer(retPtr)
	return ret
}

/*
        Returns [code]true[/code] if there is a [member network_peer] set.
	Args: [], Returns: bool
*/
func (o *MultiplayerAPI) HasNetworkPeer() gdnative.Bool {
	//log.Println("Calling MultiplayerAPI.HasNetworkPeer()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 0, 0)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("MultiplayerAPI", "has_network_peer")

	// Call the parent method.
	// bool
	retPtr := gdnative.NewEmptyBool()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := gdnative.NewBoolFromPointer(retPtr)
	return ret
}

/*
        Returns [code]true[/code] if this MultiplayerAPI's [member network_peer] is in server mode (listening for connections).
	Args: [], Returns: bool
*/
func (o *MultiplayerAPI) IsNetworkServer() gdnative.Bool {
	//log.Println("Calling MultiplayerAPI.IsNetworkServer()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 0, 0)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("MultiplayerAPI", "is_network_server")

	// Call the parent method.
	// bool
	retPtr := gdnative.NewEmptyBool()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := gdnative.NewBoolFromPointer(retPtr)
	return ret
}

/*
        Undocumented
	Args: [], Returns: bool
*/
func (o *MultiplayerAPI) IsRefusingNewNetworkConnections() gdnative.Bool {
	//log.Println("Calling MultiplayerAPI.IsRefusingNewNetworkConnections()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 0, 0)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("MultiplayerAPI", "is_refusing_new_network_connections")

	// Call the parent method.
	// bool
	retPtr := gdnative.NewEmptyBool()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := gdnative.NewBoolFromPointer(retPtr)
	return ret
}

/*
        Method used for polling the MultiplayerAPI. You only need to worry about this if you are using [member Node.custom_multiplayer] override or you set [member SceneTree.multiplayer_poll] to [code]false[/code]. By default [SceneTree] will poll its MultiplayerAPI for you. NOTE: This method results in RPCs and RSETs being called, so they will be executed in the same context of this function (e.g. [code]_process[/code], [code]physics[/code], [Thread]).
	Args: [], Returns: void
*/
func (o *MultiplayerAPI) Poll() {
	//log.Println("Calling MultiplayerAPI.Poll()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 0, 0)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("MultiplayerAPI", "poll")

	// Call the parent method.
	// void
	retPtr := gdnative.NewEmptyVoid()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

}

/*
        Sends the given raw [code]bytes[/code] to a specific peer identified by [code]id[/code] (see [method NetworkedMultiplayerPeer.set_target_peer]). Default ID is [code]0[/code], i.e. broadcast to all peers.
	Args: [{ false bytes PoolByteArray} {0 true id int} {2 true mode int}], Returns: enum.Error
*/
func (o *MultiplayerAPI) SendBytes(bytes gdnative.PoolByteArray, id gdnative.Int, mode gdnative.Int) gdnative.Error {
	//log.Println("Calling MultiplayerAPI.SendBytes()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 3, 3)
	ptrArguments[0] = gdnative.NewPointerFromPoolByteArray(bytes)
	ptrArguments[1] = gdnative.NewPointerFromInt(id)
	ptrArguments[2] = gdnative.NewPointerFromInt(mode)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("MultiplayerAPI", "send_bytes")

	// Call the parent method.
	// enum.Error
	retPtr := gdnative.NewEmptyInt()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := gdnative.NewIntFromPointer(retPtr)
	return gdnative.Error(ret)
}

/*
        Undocumented
	Args: [{ false peer NetworkedMultiplayerPeer}], Returns: void
*/
func (o *MultiplayerAPI) SetNetworkPeer(peer NetworkedMultiplayerPeerImplementer) {
	//log.Println("Calling MultiplayerAPI.SetNetworkPeer()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 1, 1)
	ptrArguments[0] = gdnative.NewPointerFromObject(peer.GetBaseObject())

	// Get the method bind
	methodBind := gdnative.NewMethodBind("MultiplayerAPI", "set_network_peer")

	// Call the parent method.
	// void
	retPtr := gdnative.NewEmptyVoid()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

}

/*
        Undocumented
	Args: [{ false refuse bool}], Returns: void
*/
func (o *MultiplayerAPI) SetRefuseNewNetworkConnections(refuse gdnative.Bool) {
	//log.Println("Calling MultiplayerAPI.SetRefuseNewNetworkConnections()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 1, 1)
	ptrArguments[0] = gdnative.NewPointerFromBool(refuse)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("MultiplayerAPI", "set_refuse_new_network_connections")

	// Call the parent method.
	// void
	retPtr := gdnative.NewEmptyVoid()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

}

/*
        Sets the base root node to use for RPCs. Instead of an absolute path, a relative path will be used to find the node upon which the RPC should be executed. This effectively allows to have different branches of the scene tree to be managed by different MultiplayerAPI, allowing for example to run both client and server in the same scene.
	Args: [{ false node Object}], Returns: void
*/
func (o *MultiplayerAPI) SetRootNode(node ObjectImplementer) {
	//log.Println("Calling MultiplayerAPI.SetRootNode()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 1, 1)
	ptrArguments[0] = gdnative.NewPointerFromObject(node.GetBaseObject())

	// Get the method bind
	methodBind := gdnative.NewMethodBind("MultiplayerAPI", "set_root_node")

	// Call the parent method.
	// void
	retPtr := gdnative.NewEmptyVoid()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

}

// MultiplayerAPIImplementer is an interface that implements the methods
// of the MultiplayerAPI class.
type MultiplayerAPIImplementer interface {
	ReferenceImplementer
	X_AddPeer(id gdnative.Int)
	X_ConnectedToServer()
	X_ConnectionFailed()
	X_DelPeer(id gdnative.Int)
	X_ServerDisconnected()
	Clear()
	GetNetworkConnectedPeers() gdnative.PoolIntArray
	GetNetworkPeer() NetworkedMultiplayerPeerImplementer
	GetNetworkUniqueId() gdnative.Int
	GetRpcSenderId() gdnative.Int
	HasNetworkPeer() gdnative.Bool
	IsNetworkServer() gdnative.Bool
	IsRefusingNewNetworkConnections() gdnative.Bool
	Poll()
	SetNetworkPeer(peer NetworkedMultiplayerPeerImplementer)
	SetRefuseNewNetworkConnections(refuse gdnative.Bool)
	SetRootNode(node ObjectImplementer)
}
