package godot

import (
	"github.com/shadowapex/godot-go/gdnative"
)

/*------------------------------------------------------------------------------
//   This code was generated by a tool.
//
//   Changes to this file may cause incorrect behavior and will be lost if
//   the code is regenerated. Any updates should be done in
//   "class.go.tmpl" so they can be included in the generated
//   code.
//----------------------------------------------------------------------------*/

// SceneTreeGroupCallFlags is an enum for GroupCallFlags values.
type SceneTreeGroupCallFlags int

const (
	SceneTreeGroupCallDefault  SceneTreeGroupCallFlags = 0
	SceneTreeGroupCallRealtime SceneTreeGroupCallFlags = 2
	SceneTreeGroupCallReverse  SceneTreeGroupCallFlags = 1
	SceneTreeGroupCallUnique   SceneTreeGroupCallFlags = 4
)

// SceneTreeStretchAspect is an enum for StretchAspect values.
type SceneTreeStretchAspect int

const (
	SceneTreeStretchAspectExpand     SceneTreeStretchAspect = 4
	SceneTreeStretchAspectIgnore     SceneTreeStretchAspect = 0
	SceneTreeStretchAspectKeep       SceneTreeStretchAspect = 1
	SceneTreeStretchAspectKeepHeight SceneTreeStretchAspect = 3
	SceneTreeStretchAspectKeepWidth  SceneTreeStretchAspect = 2
)

// SceneTreeStretchMode is an enum for StretchMode values.
type SceneTreeStretchMode int

const (
	SceneTreeStretchMode2D       SceneTreeStretchMode = 1
	SceneTreeStretchModeDisabled SceneTreeStretchMode = 0
	SceneTreeStretchModeViewport SceneTreeStretchMode = 2
)

//func NewSceneTreeFromPointer(ptr gdnative.Pointer) SceneTree {
func newSceneTreeFromPointer(ptr gdnative.Pointer) SceneTree {
	owner := gdnative.NewObjectFromPointer(ptr)
	obj := SceneTree{}
	obj.SetBaseObject(owner)

	return obj
}

/*
As one of the most important classes, the [code]SceneTree[/code] manages the hierarchy of nodes in a scene as well as scenes themselves. Nodes can be added, retrieved and removed. The whole scene tree (and thus the current scene) can be paused. Scenes can be loaded, switched and reloaded. You can also use the SceneTree to organize your nodes into groups: every node can be assigned as many groups as you want to create, e.g. a "enemy" group. You can then iterate these groups or even call methods and set properties on all the group's members at once.
*/
type SceneTree struct {
	MainLoop
	owner gdnative.Object
}

func (o *SceneTree) BaseClass() string {
	return "SceneTree"
}

/*
        Undocumented
	Args: [{ false arg0 Object}], Returns: void
*/
func (o *SceneTree) X_ChangeScene(arg0 ObjectImplementer) {
	//log.Println("Calling SceneTree.X_ChangeScene()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 1, 1)
	ptrArguments[0] = gdnative.NewPointerFromObject(arg0.GetBaseObject())

	// Get the method bind
	methodBind := gdnative.NewMethodBind("SceneTree", "_change_scene")

	// Call the parent method.
	// void
	retPtr := gdnative.NewEmptyVoid()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

}

/*
        Undocumented
	Args: [], Returns: void
*/
func (o *SceneTree) X_ConnectedToServer() {
	//log.Println("Calling SceneTree.X_ConnectedToServer()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 0, 0)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("SceneTree", "_connected_to_server")

	// Call the parent method.
	// void
	retPtr := gdnative.NewEmptyVoid()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

}

/*
        Undocumented
	Args: [], Returns: void
*/
func (o *SceneTree) X_ConnectionFailed() {
	//log.Println("Calling SceneTree.X_ConnectionFailed()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 0, 0)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("SceneTree", "_connection_failed")

	// Call the parent method.
	// void
	retPtr := gdnative.NewEmptyVoid()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

}

/*
        Undocumented
	Args: [{ false arg0 int}], Returns: void
*/
func (o *SceneTree) X_NetworkPeerConnected(arg0 gdnative.Int) {
	//log.Println("Calling SceneTree.X_NetworkPeerConnected()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 1, 1)
	ptrArguments[0] = gdnative.NewPointerFromInt(arg0)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("SceneTree", "_network_peer_connected")

	// Call the parent method.
	// void
	retPtr := gdnative.NewEmptyVoid()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

}

/*
        Undocumented
	Args: [{ false arg0 int}], Returns: void
*/
func (o *SceneTree) X_NetworkPeerDisconnected(arg0 gdnative.Int) {
	//log.Println("Calling SceneTree.X_NetworkPeerDisconnected()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 1, 1)
	ptrArguments[0] = gdnative.NewPointerFromInt(arg0)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("SceneTree", "_network_peer_disconnected")

	// Call the parent method.
	// void
	retPtr := gdnative.NewEmptyVoid()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

}

/*
        Undocumented
	Args: [], Returns: void
*/
func (o *SceneTree) X_ServerDisconnected() {
	//log.Println("Calling SceneTree.X_ServerDisconnected()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 0, 0)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("SceneTree", "_server_disconnected")

	// Call the parent method.
	// void
	retPtr := gdnative.NewEmptyVoid()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

}

/*
        Calls [code]method[/code] on each member of the given group.
	Args: [{ false group String} { false method String}], Returns: Variant
*/
func (o *SceneTree) CallGroup(group gdnative.String, method gdnative.String) gdnative.Variant {
	//log.Println("Calling SceneTree.CallGroup()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 2, 2)
	ptrArguments[0] = gdnative.NewPointerFromString(group)
	ptrArguments[1] = gdnative.NewPointerFromString(method)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("SceneTree", "call_group")

	// Call the parent method.
	// Variant
	retPtr := gdnative.NewEmptyVariant()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := gdnative.NewVariantFromPointer(retPtr)
	return ret
}

/*
        Calls [code]method[/code] on each member of the given group, respecting the given [enum GroupCallFlags].
	Args: [{ false flags int} { false group String} { false method String}], Returns: Variant
*/
func (o *SceneTree) CallGroupFlags(flags gdnative.Int, group gdnative.String, method gdnative.String) gdnative.Variant {
	//log.Println("Calling SceneTree.CallGroupFlags()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 3, 3)
	ptrArguments[0] = gdnative.NewPointerFromInt(flags)
	ptrArguments[1] = gdnative.NewPointerFromString(group)
	ptrArguments[2] = gdnative.NewPointerFromString(method)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("SceneTree", "call_group_flags")

	// Call the parent method.
	// Variant
	retPtr := gdnative.NewEmptyVariant()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := gdnative.NewVariantFromPointer(retPtr)
	return ret
}

/*
        Changes to the scene at the given [code]path[/code].
	Args: [{ false path String}], Returns: enum.Error
*/
func (o *SceneTree) ChangeScene(path gdnative.String) gdnative.Error {
	//log.Println("Calling SceneTree.ChangeScene()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 1, 1)
	ptrArguments[0] = gdnative.NewPointerFromString(path)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("SceneTree", "change_scene")

	// Call the parent method.
	// enum.Error
	retPtr := gdnative.NewEmptyInt()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := gdnative.NewIntFromPointer(retPtr)
	return gdnative.Error(ret)
}

/*
        Changes to the given [PackedScene].
	Args: [{ false packed_scene PackedScene}], Returns: enum.Error
*/
func (o *SceneTree) ChangeSceneTo(packedScene PackedSceneImplementer) gdnative.Error {
	//log.Println("Calling SceneTree.ChangeSceneTo()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 1, 1)
	ptrArguments[0] = gdnative.NewPointerFromObject(packedScene.GetBaseObject())

	// Get the method bind
	methodBind := gdnative.NewMethodBind("SceneTree", "change_scene_to")

	// Call the parent method.
	// enum.Error
	retPtr := gdnative.NewEmptyInt()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := gdnative.NewIntFromPointer(retPtr)
	return gdnative.Error(ret)
}

/*
        Returns a [SceneTreeTimer] which will [signal SceneTreeTimer.timeout] after the given time in seconds elapsed in this SceneTree. If [code]pause_mode_process[/code] is set to false, pausing the SceneTree will also pause the timer. Commonly used to create a one-shot delay timer as in the following example: [codeblock] func some_function(): print("start") yield(get_tree().create_timer(1.0), "timeout") print("end") [/codeblock]
	Args: [{ false time_sec float} {True true pause_mode_process bool}], Returns: SceneTreeTimer
*/
func (o *SceneTree) CreateTimer(timeSec gdnative.Real, pauseModeProcess gdnative.Bool) SceneTreeTimerImplementer {
	//log.Println("Calling SceneTree.CreateTimer()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 2, 2)
	ptrArguments[0] = gdnative.NewPointerFromReal(timeSec)
	ptrArguments[1] = gdnative.NewPointerFromBool(pauseModeProcess)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("SceneTree", "create_timer")

	// Call the parent method.
	// SceneTreeTimer
	retPtr := gdnative.NewEmptyObject()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := newSceneTreeTimerFromPointer(retPtr)

	// Check to see if we already have an instance of this object in our Go instance registry.
	if instance, ok := InstanceRegistry.Get(ret.GetBaseObject().ID()); ok {
		return instance.(SceneTreeTimerImplementer)
	}

	// Check to see what kind of class this is and create it. This is generally used with
	// GetNode().
	className := ret.GetClass()
	if className != "SceneTreeTimer" {
		actualRet := getActualClass(className, ret.GetBaseObject())
		return actualRet.(SceneTreeTimerImplementer)
	}

	return &ret
}

/*
        Undocumented
	Args: [], Returns: Node
*/
func (o *SceneTree) GetCurrentScene() NodeImplementer {
	//log.Println("Calling SceneTree.GetCurrentScene()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 0, 0)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("SceneTree", "get_current_scene")

	// Call the parent method.
	// Node
	retPtr := gdnative.NewEmptyObject()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := newNodeFromPointer(retPtr)

	// Check to see if we already have an instance of this object in our Go instance registry.
	if instance, ok := InstanceRegistry.Get(ret.GetBaseObject().ID()); ok {
		return instance.(NodeImplementer)
	}

	// Check to see what kind of class this is and create it. This is generally used with
	// GetNode().
	className := ret.GetClass()
	if className != "Node" {
		actualRet := getActualClass(className, ret.GetBaseObject())
		return actualRet.(NodeImplementer)
	}

	return &ret
}

/*
        Undocumented
	Args: [], Returns: Node
*/
func (o *SceneTree) GetEditedSceneRoot() NodeImplementer {
	//log.Println("Calling SceneTree.GetEditedSceneRoot()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 0, 0)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("SceneTree", "get_edited_scene_root")

	// Call the parent method.
	// Node
	retPtr := gdnative.NewEmptyObject()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := newNodeFromPointer(retPtr)

	// Check to see if we already have an instance of this object in our Go instance registry.
	if instance, ok := InstanceRegistry.Get(ret.GetBaseObject().ID()); ok {
		return instance.(NodeImplementer)
	}

	// Check to see what kind of class this is and create it. This is generally used with
	// GetNode().
	className := ret.GetClass()
	if className != "Node" {
		actualRet := getActualClass(className, ret.GetBaseObject())
		return actualRet.(NodeImplementer)
	}

	return &ret
}

/*

	Args: [], Returns: int
*/
func (o *SceneTree) GetFrame() gdnative.Int {
	//log.Println("Calling SceneTree.GetFrame()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 0, 0)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("SceneTree", "get_frame")

	// Call the parent method.
	// int
	retPtr := gdnative.NewEmptyInt()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := gdnative.NewIntFromPointer(retPtr)
	return ret
}

/*
        Undocumented
	Args: [], Returns: MultiplayerAPI
*/
func (o *SceneTree) GetMultiplayer() MultiplayerAPIImplementer {
	//log.Println("Calling SceneTree.GetMultiplayer()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 0, 0)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("SceneTree", "get_multiplayer")

	// Call the parent method.
	// MultiplayerAPI
	retPtr := gdnative.NewEmptyObject()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := newMultiplayerAPIFromPointer(retPtr)

	// Check to see if we already have an instance of this object in our Go instance registry.
	if instance, ok := InstanceRegistry.Get(ret.GetBaseObject().ID()); ok {
		return instance.(MultiplayerAPIImplementer)
	}

	// Check to see what kind of class this is and create it. This is generally used with
	// GetNode().
	className := ret.GetClass()
	if className != "MultiplayerAPI" {
		actualRet := getActualClass(className, ret.GetBaseObject())
		return actualRet.(MultiplayerAPIImplementer)
	}

	return &ret
}

/*
        Returns the peer IDs of all connected peers of this SceneTree's [member network_peer].
	Args: [], Returns: PoolIntArray
*/
func (o *SceneTree) GetNetworkConnectedPeers() gdnative.PoolIntArray {
	//log.Println("Calling SceneTree.GetNetworkConnectedPeers()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 0, 0)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("SceneTree", "get_network_connected_peers")

	// Call the parent method.
	// PoolIntArray
	retPtr := gdnative.NewEmptyPoolIntArray()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := gdnative.NewPoolIntArrayFromPointer(retPtr)
	return ret
}

/*
        Undocumented
	Args: [], Returns: NetworkedMultiplayerPeer
*/
func (o *SceneTree) GetNetworkPeer() NetworkedMultiplayerPeerImplementer {
	//log.Println("Calling SceneTree.GetNetworkPeer()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 0, 0)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("SceneTree", "get_network_peer")

	// Call the parent method.
	// NetworkedMultiplayerPeer
	retPtr := gdnative.NewEmptyObject()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := newNetworkedMultiplayerPeerFromPointer(retPtr)

	// Check to see if we already have an instance of this object in our Go instance registry.
	if instance, ok := InstanceRegistry.Get(ret.GetBaseObject().ID()); ok {
		return instance.(NetworkedMultiplayerPeerImplementer)
	}

	// Check to see what kind of class this is and create it. This is generally used with
	// GetNode().
	className := ret.GetClass()
	if className != "NetworkedMultiplayerPeer" {
		actualRet := getActualClass(className, ret.GetBaseObject())
		return actualRet.(NetworkedMultiplayerPeerImplementer)
	}

	return &ret
}

/*
        Returns the unique peer ID of this SceneTree's [member network_peer].
	Args: [], Returns: int
*/
func (o *SceneTree) GetNetworkUniqueId() gdnative.Int {
	//log.Println("Calling SceneTree.GetNetworkUniqueId()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 0, 0)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("SceneTree", "get_network_unique_id")

	// Call the parent method.
	// int
	retPtr := gdnative.NewEmptyInt()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := gdnative.NewIntFromPointer(retPtr)
	return ret
}

/*
        Returns the number of nodes in this SceneTree.
	Args: [], Returns: int
*/
func (o *SceneTree) GetNodeCount() gdnative.Int {
	//log.Println("Calling SceneTree.GetNodeCount()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 0, 0)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("SceneTree", "get_node_count")

	// Call the parent method.
	// int
	retPtr := gdnative.NewEmptyInt()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := gdnative.NewIntFromPointer(retPtr)
	return ret
}

/*
        Returns all nodes assigned to the given group.
	Args: [{ false group String}], Returns: Array
*/
func (o *SceneTree) GetNodesInGroup(group gdnative.String) gdnative.Array {
	//log.Println("Calling SceneTree.GetNodesInGroup()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 1, 1)
	ptrArguments[0] = gdnative.NewPointerFromString(group)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("SceneTree", "get_nodes_in_group")

	// Call the parent method.
	// Array
	retPtr := gdnative.NewEmptyArray()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := gdnative.NewArrayFromPointer(retPtr)
	return ret
}

/*
        Undocumented
	Args: [], Returns: Viewport
*/
func (o *SceneTree) GetRoot() ViewportImplementer {
	//log.Println("Calling SceneTree.GetRoot()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 0, 0)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("SceneTree", "get_root")

	// Call the parent method.
	// Viewport
	retPtr := gdnative.NewEmptyObject()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := newViewportFromPointer(retPtr)

	// Check to see if we already have an instance of this object in our Go instance registry.
	if instance, ok := InstanceRegistry.Get(ret.GetBaseObject().ID()); ok {
		return instance.(ViewportImplementer)
	}

	// Check to see what kind of class this is and create it. This is generally used with
	// GetNode().
	className := ret.GetClass()
	if className != "Viewport" {
		actualRet := getActualClass(className, ret.GetBaseObject())
		return actualRet.(ViewportImplementer)
	}

	return &ret
}

/*
        Returns the sender's peer ID for the most recently received RPC call.
	Args: [], Returns: int
*/
func (o *SceneTree) GetRpcSenderId() gdnative.Int {
	//log.Println("Calling SceneTree.GetRpcSenderId()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 0, 0)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("SceneTree", "get_rpc_sender_id")

	// Call the parent method.
	// int
	retPtr := gdnative.NewEmptyInt()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := gdnative.NewIntFromPointer(retPtr)
	return ret
}

/*
        Returns [code]true[/code] if the given group exists.
	Args: [{ false name String}], Returns: bool
*/
func (o *SceneTree) HasGroup(name gdnative.String) gdnative.Bool {
	//log.Println("Calling SceneTree.HasGroup()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 1, 1)
	ptrArguments[0] = gdnative.NewPointerFromString(name)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("SceneTree", "has_group")

	// Call the parent method.
	// bool
	retPtr := gdnative.NewEmptyBool()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := gdnative.NewBoolFromPointer(retPtr)
	return ret
}

/*
        Returns [code]true[/code] if there is a [member network_peer] set.
	Args: [], Returns: bool
*/
func (o *SceneTree) HasNetworkPeer() gdnative.Bool {
	//log.Println("Calling SceneTree.HasNetworkPeer()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 0, 0)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("SceneTree", "has_network_peer")

	// Call the parent method.
	// bool
	retPtr := gdnative.NewEmptyBool()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := gdnative.NewBoolFromPointer(retPtr)
	return ret
}

/*
        Undocumented
	Args: [], Returns: bool
*/
func (o *SceneTree) IsDebuggingCollisionsHint() gdnative.Bool {
	//log.Println("Calling SceneTree.IsDebuggingCollisionsHint()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 0, 0)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("SceneTree", "is_debugging_collisions_hint")

	// Call the parent method.
	// bool
	retPtr := gdnative.NewEmptyBool()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := gdnative.NewBoolFromPointer(retPtr)
	return ret
}

/*
        Undocumented
	Args: [], Returns: bool
*/
func (o *SceneTree) IsDebuggingNavigationHint() gdnative.Bool {
	//log.Println("Calling SceneTree.IsDebuggingNavigationHint()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 0, 0)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("SceneTree", "is_debugging_navigation_hint")

	// Call the parent method.
	// bool
	retPtr := gdnative.NewEmptyBool()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := gdnative.NewBoolFromPointer(retPtr)
	return ret
}

/*
        Returns [code]true[/code] if the most recent InputEvent was marked as handled with [method set_input_as_handled].
	Args: [], Returns: bool
*/
func (o *SceneTree) IsInputHandled() gdnative.Bool {
	//log.Println("Calling SceneTree.IsInputHandled()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 0, 0)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("SceneTree", "is_input_handled")

	// Call the parent method.
	// bool
	retPtr := gdnative.NewEmptyBool()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := gdnative.NewBoolFromPointer(retPtr)
	return ret
}

/*
        Undocumented
	Args: [], Returns: bool
*/
func (o *SceneTree) IsMultiplayerPollEnabled() gdnative.Bool {
	//log.Println("Calling SceneTree.IsMultiplayerPollEnabled()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 0, 0)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("SceneTree", "is_multiplayer_poll_enabled")

	// Call the parent method.
	// bool
	retPtr := gdnative.NewEmptyBool()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := gdnative.NewBoolFromPointer(retPtr)
	return ret
}

/*
        Returns [code]true[/code] if this SceneTree's [member network_peer] is in server mode (listening for connections).
	Args: [], Returns: bool
*/
func (o *SceneTree) IsNetworkServer() gdnative.Bool {
	//log.Println("Calling SceneTree.IsNetworkServer()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 0, 0)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("SceneTree", "is_network_server")

	// Call the parent method.
	// bool
	retPtr := gdnative.NewEmptyBool()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := gdnative.NewBoolFromPointer(retPtr)
	return ret
}

/*
        Undocumented
	Args: [], Returns: bool
*/
func (o *SceneTree) IsPaused() gdnative.Bool {
	//log.Println("Calling SceneTree.IsPaused()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 0, 0)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("SceneTree", "is_paused")

	// Call the parent method.
	// bool
	retPtr := gdnative.NewEmptyBool()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := gdnative.NewBoolFromPointer(retPtr)
	return ret
}

/*
        Undocumented
	Args: [], Returns: bool
*/
func (o *SceneTree) IsRefusingNewNetworkConnections() gdnative.Bool {
	//log.Println("Calling SceneTree.IsRefusingNewNetworkConnections()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 0, 0)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("SceneTree", "is_refusing_new_network_connections")

	// Call the parent method.
	// bool
	retPtr := gdnative.NewEmptyBool()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := gdnative.NewBoolFromPointer(retPtr)
	return ret
}

/*
        Undocumented
	Args: [], Returns: bool
*/
func (o *SceneTree) IsUsingFontOversampling() gdnative.Bool {
	//log.Println("Calling SceneTree.IsUsingFontOversampling()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 0, 0)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("SceneTree", "is_using_font_oversampling")

	// Call the parent method.
	// bool
	retPtr := gdnative.NewEmptyBool()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := gdnative.NewBoolFromPointer(retPtr)
	return ret
}

/*
        Sends the given notification to all members of the [code]group[/code].
	Args: [{ false group String} { false notification int}], Returns: void
*/
func (o *SceneTree) NotifyGroup(group gdnative.String, notification gdnative.Int) {
	//log.Println("Calling SceneTree.NotifyGroup()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 2, 2)
	ptrArguments[0] = gdnative.NewPointerFromString(group)
	ptrArguments[1] = gdnative.NewPointerFromInt(notification)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("SceneTree", "notify_group")

	// Call the parent method.
	// void
	retPtr := gdnative.NewEmptyVoid()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

}

/*
        Sends the given notification to all members of the [code]group[/code], respecting the given [enum GroupCallFlags].
	Args: [{ false call_flags int} { false group String} { false notification int}], Returns: void
*/
func (o *SceneTree) NotifyGroupFlags(callFlags gdnative.Int, group gdnative.String, notification gdnative.Int) {
	//log.Println("Calling SceneTree.NotifyGroupFlags()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 3, 3)
	ptrArguments[0] = gdnative.NewPointerFromInt(callFlags)
	ptrArguments[1] = gdnative.NewPointerFromString(group)
	ptrArguments[2] = gdnative.NewPointerFromInt(notification)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("SceneTree", "notify_group_flags")

	// Call the parent method.
	// void
	retPtr := gdnative.NewEmptyVoid()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

}

/*
        Queues the given object for deletion, delaying the call to [method Object.free] to after the current frame.
	Args: [{ false obj Object}], Returns: void
*/
func (o *SceneTree) QueueDelete(obj ObjectImplementer) {
	//log.Println("Calling SceneTree.QueueDelete()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 1, 1)
	ptrArguments[0] = gdnative.NewPointerFromObject(obj.GetBaseObject())

	// Get the method bind
	methodBind := gdnative.NewMethodBind("SceneTree", "queue_delete")

	// Call the parent method.
	// void
	retPtr := gdnative.NewEmptyVoid()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

}

/*
        Quits the application.
	Args: [], Returns: void
*/
func (o *SceneTree) Quit() {
	//log.Println("Calling SceneTree.Quit()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 0, 0)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("SceneTree", "quit")

	// Call the parent method.
	// void
	retPtr := gdnative.NewEmptyVoid()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

}

/*
        Reloads the currently active scene.
	Args: [], Returns: enum.Error
*/
func (o *SceneTree) ReloadCurrentScene() gdnative.Error {
	//log.Println("Calling SceneTree.ReloadCurrentScene()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 0, 0)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("SceneTree", "reload_current_scene")

	// Call the parent method.
	// enum.Error
	retPtr := gdnative.NewEmptyInt()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := gdnative.NewIntFromPointer(retPtr)
	return gdnative.Error(ret)
}

/*
        If [code]true[/code], the application automatically accepts quitting.
	Args: [{ false enabled bool}], Returns: void
*/
func (o *SceneTree) SetAutoAcceptQuit(enabled gdnative.Bool) {
	//log.Println("Calling SceneTree.SetAutoAcceptQuit()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 1, 1)
	ptrArguments[0] = gdnative.NewPointerFromBool(enabled)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("SceneTree", "set_auto_accept_quit")

	// Call the parent method.
	// void
	retPtr := gdnative.NewEmptyVoid()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

}

/*
        Undocumented
	Args: [{ false child_node Object}], Returns: void
*/
func (o *SceneTree) SetCurrentScene(childNode ObjectImplementer) {
	//log.Println("Calling SceneTree.SetCurrentScene()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 1, 1)
	ptrArguments[0] = gdnative.NewPointerFromObject(childNode.GetBaseObject())

	// Get the method bind
	methodBind := gdnative.NewMethodBind("SceneTree", "set_current_scene")

	// Call the parent method.
	// void
	retPtr := gdnative.NewEmptyVoid()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

}

/*
        Undocumented
	Args: [{ false enable bool}], Returns: void
*/
func (o *SceneTree) SetDebugCollisionsHint(enable gdnative.Bool) {
	//log.Println("Calling SceneTree.SetDebugCollisionsHint()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 1, 1)
	ptrArguments[0] = gdnative.NewPointerFromBool(enable)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("SceneTree", "set_debug_collisions_hint")

	// Call the parent method.
	// void
	retPtr := gdnative.NewEmptyVoid()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

}

/*
        Undocumented
	Args: [{ false enable bool}], Returns: void
*/
func (o *SceneTree) SetDebugNavigationHint(enable gdnative.Bool) {
	//log.Println("Calling SceneTree.SetDebugNavigationHint()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 1, 1)
	ptrArguments[0] = gdnative.NewPointerFromBool(enable)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("SceneTree", "set_debug_navigation_hint")

	// Call the parent method.
	// void
	retPtr := gdnative.NewEmptyVoid()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

}

/*
        Undocumented
	Args: [{ false scene Object}], Returns: void
*/
func (o *SceneTree) SetEditedSceneRoot(scene ObjectImplementer) {
	//log.Println("Calling SceneTree.SetEditedSceneRoot()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 1, 1)
	ptrArguments[0] = gdnative.NewPointerFromObject(scene.GetBaseObject())

	// Get the method bind
	methodBind := gdnative.NewMethodBind("SceneTree", "set_edited_scene_root")

	// Call the parent method.
	// void
	retPtr := gdnative.NewEmptyVoid()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

}

/*
        Sets the given [code]property[/code] to [code]value[/code] on all members of the given group.
	Args: [{ false group String} { false property String} { false value Variant}], Returns: void
*/
func (o *SceneTree) SetGroup(group gdnative.String, property gdnative.String, value gdnative.Variant) {
	//log.Println("Calling SceneTree.SetGroup()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 3, 3)
	ptrArguments[0] = gdnative.NewPointerFromString(group)
	ptrArguments[1] = gdnative.NewPointerFromString(property)
	ptrArguments[2] = gdnative.NewPointerFromVariant(value)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("SceneTree", "set_group")

	// Call the parent method.
	// void
	retPtr := gdnative.NewEmptyVoid()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

}

/*
        Sets the given [code]property[/code] to [code]value[/code] on all members of the given group, respecting the given [enum GroupCallFlags].
	Args: [{ false call_flags int} { false group String} { false property String} { false value Variant}], Returns: void
*/
func (o *SceneTree) SetGroupFlags(callFlags gdnative.Int, group gdnative.String, property gdnative.String, value gdnative.Variant) {
	//log.Println("Calling SceneTree.SetGroupFlags()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 4, 4)
	ptrArguments[0] = gdnative.NewPointerFromInt(callFlags)
	ptrArguments[1] = gdnative.NewPointerFromString(group)
	ptrArguments[2] = gdnative.NewPointerFromString(property)
	ptrArguments[3] = gdnative.NewPointerFromVariant(value)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("SceneTree", "set_group_flags")

	// Call the parent method.
	// void
	retPtr := gdnative.NewEmptyVoid()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

}

/*
        Marks the most recent input event as handled.
	Args: [], Returns: void
*/
func (o *SceneTree) SetInputAsHandled() {
	//log.Println("Calling SceneTree.SetInputAsHandled()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 0, 0)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("SceneTree", "set_input_as_handled")

	// Call the parent method.
	// void
	retPtr := gdnative.NewEmptyVoid()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

}

/*
        Undocumented
	Args: [{ false multiplayer MultiplayerAPI}], Returns: void
*/
func (o *SceneTree) SetMultiplayer(multiplayer MultiplayerAPIImplementer) {
	//log.Println("Calling SceneTree.SetMultiplayer()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 1, 1)
	ptrArguments[0] = gdnative.NewPointerFromObject(multiplayer.GetBaseObject())

	// Get the method bind
	methodBind := gdnative.NewMethodBind("SceneTree", "set_multiplayer")

	// Call the parent method.
	// void
	retPtr := gdnative.NewEmptyVoid()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

}

/*
        Undocumented
	Args: [{ false enabled bool}], Returns: void
*/
func (o *SceneTree) SetMultiplayerPollEnabled(enabled gdnative.Bool) {
	//log.Println("Calling SceneTree.SetMultiplayerPollEnabled()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 1, 1)
	ptrArguments[0] = gdnative.NewPointerFromBool(enabled)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("SceneTree", "set_multiplayer_poll_enabled")

	// Call the parent method.
	// void
	retPtr := gdnative.NewEmptyVoid()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

}

/*
        Undocumented
	Args: [{ false peer NetworkedMultiplayerPeer}], Returns: void
*/
func (o *SceneTree) SetNetworkPeer(peer NetworkedMultiplayerPeerImplementer) {
	//log.Println("Calling SceneTree.SetNetworkPeer()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 1, 1)
	ptrArguments[0] = gdnative.NewPointerFromObject(peer.GetBaseObject())

	// Get the method bind
	methodBind := gdnative.NewMethodBind("SceneTree", "set_network_peer")

	// Call the parent method.
	// void
	retPtr := gdnative.NewEmptyVoid()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

}

/*
        Undocumented
	Args: [{ false enable bool}], Returns: void
*/
func (o *SceneTree) SetPause(enable gdnative.Bool) {
	//log.Println("Calling SceneTree.SetPause()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 1, 1)
	ptrArguments[0] = gdnative.NewPointerFromBool(enable)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("SceneTree", "set_pause")

	// Call the parent method.
	// void
	retPtr := gdnative.NewEmptyVoid()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

}

/*
        If [code]true[/code], the application quits automatically on going back (e.g. on Android).
	Args: [{ false enabled bool}], Returns: void
*/
func (o *SceneTree) SetQuitOnGoBack(enabled gdnative.Bool) {
	//log.Println("Calling SceneTree.SetQuitOnGoBack()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 1, 1)
	ptrArguments[0] = gdnative.NewPointerFromBool(enabled)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("SceneTree", "set_quit_on_go_back")

	// Call the parent method.
	// void
	retPtr := gdnative.NewEmptyVoid()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

}

/*
        Undocumented
	Args: [{ false refuse bool}], Returns: void
*/
func (o *SceneTree) SetRefuseNewNetworkConnections(refuse gdnative.Bool) {
	//log.Println("Calling SceneTree.SetRefuseNewNetworkConnections()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 1, 1)
	ptrArguments[0] = gdnative.NewPointerFromBool(refuse)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("SceneTree", "set_refuse_new_network_connections")

	// Call the parent method.
	// void
	retPtr := gdnative.NewEmptyVoid()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

}

/*
        Configures screen stretching to the given [enum StretchMode], [enum StretchAspect], minimum size and [code]shrink[/code].
	Args: [{ false mode int} { false aspect int} { false minsize Vector2} {1 true shrink float}], Returns: void
*/
func (o *SceneTree) SetScreenStretch(mode gdnative.Int, aspect gdnative.Int, minsize gdnative.Vector2, shrink gdnative.Real) {
	//log.Println("Calling SceneTree.SetScreenStretch()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 4, 4)
	ptrArguments[0] = gdnative.NewPointerFromInt(mode)
	ptrArguments[1] = gdnative.NewPointerFromInt(aspect)
	ptrArguments[2] = gdnative.NewPointerFromVector2(minsize)
	ptrArguments[3] = gdnative.NewPointerFromReal(shrink)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("SceneTree", "set_screen_stretch")

	// Call the parent method.
	// void
	retPtr := gdnative.NewEmptyVoid()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

}

/*
        Undocumented
	Args: [{ false enable bool}], Returns: void
*/
func (o *SceneTree) SetUseFontOversampling(enable gdnative.Bool) {
	//log.Println("Calling SceneTree.SetUseFontOversampling()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 1, 1)
	ptrArguments[0] = gdnative.NewPointerFromBool(enable)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("SceneTree", "set_use_font_oversampling")

	// Call the parent method.
	// void
	retPtr := gdnative.NewEmptyVoid()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

}

// SceneTreeImplementer is an interface that implements the methods
// of the SceneTree class.
type SceneTreeImplementer interface {
	MainLoopImplementer
	X_ChangeScene(arg0 ObjectImplementer)
	X_ConnectedToServer()
	X_ConnectionFailed()
	X_NetworkPeerConnected(arg0 gdnative.Int)
	X_NetworkPeerDisconnected(arg0 gdnative.Int)
	X_ServerDisconnected()
	CallGroup(group gdnative.String, method gdnative.String) gdnative.Variant
	CallGroupFlags(flags gdnative.Int, group gdnative.String, method gdnative.String) gdnative.Variant
	CreateTimer(timeSec gdnative.Real, pauseModeProcess gdnative.Bool) SceneTreeTimerImplementer
	GetCurrentScene() NodeImplementer
	GetEditedSceneRoot() NodeImplementer
	GetFrame() gdnative.Int
	GetMultiplayer() MultiplayerAPIImplementer
	GetNetworkConnectedPeers() gdnative.PoolIntArray
	GetNetworkPeer() NetworkedMultiplayerPeerImplementer
	GetNetworkUniqueId() gdnative.Int
	GetNodeCount() gdnative.Int
	GetNodesInGroup(group gdnative.String) gdnative.Array
	GetRoot() ViewportImplementer
	GetRpcSenderId() gdnative.Int
	HasGroup(name gdnative.String) gdnative.Bool
	HasNetworkPeer() gdnative.Bool
	IsDebuggingCollisionsHint() gdnative.Bool
	IsDebuggingNavigationHint() gdnative.Bool
	IsInputHandled() gdnative.Bool
	IsMultiplayerPollEnabled() gdnative.Bool
	IsNetworkServer() gdnative.Bool
	IsPaused() gdnative.Bool
	IsRefusingNewNetworkConnections() gdnative.Bool
	IsUsingFontOversampling() gdnative.Bool
	NotifyGroup(group gdnative.String, notification gdnative.Int)
	NotifyGroupFlags(callFlags gdnative.Int, group gdnative.String, notification gdnative.Int)
	QueueDelete(obj ObjectImplementer)
	Quit()
	SetAutoAcceptQuit(enabled gdnative.Bool)
	SetCurrentScene(childNode ObjectImplementer)
	SetDebugCollisionsHint(enable gdnative.Bool)
	SetDebugNavigationHint(enable gdnative.Bool)
	SetEditedSceneRoot(scene ObjectImplementer)
	SetGroup(group gdnative.String, property gdnative.String, value gdnative.Variant)
	SetGroupFlags(callFlags gdnative.Int, group gdnative.String, property gdnative.String, value gdnative.Variant)
	SetInputAsHandled()
	SetMultiplayer(multiplayer MultiplayerAPIImplementer)
	SetMultiplayerPollEnabled(enabled gdnative.Bool)
	SetNetworkPeer(peer NetworkedMultiplayerPeerImplementer)
	SetPause(enable gdnative.Bool)
	SetQuitOnGoBack(enabled gdnative.Bool)
	SetRefuseNewNetworkConnections(refuse gdnative.Bool)
	SetScreenStretch(mode gdnative.Int, aspect gdnative.Int, minsize gdnative.Vector2, shrink gdnative.Real)
	SetUseFontOversampling(enable gdnative.Bool)
}
